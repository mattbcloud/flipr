<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-CZ2LT19WG4"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-CZ2LT19WG4');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flipr</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-storage-compat.js"></script>
    <style>
        :root {
            --primary-color: #39FF14; /* Neon green */
            --secondary-color: #FF10F0; /* Neon pink */
            --background-color: #000000; /* Black background */
            --card-bg: #111111; /* Dark card background */
            --text-color: #ffffff; /* White text */
            --border-color: #333333; /* Darker borders */
            --secondary-text: #cccccc; /* Lighter gray for secondary text */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            min-height: 100vh;
        }

        header {
            background-color: rgba(17, 17, 17, 0.9);
            padding: 1rem;
            box-shadow: 0 2px 10px rgba(57, 255, 20, 0.3);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--primary-color);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .leaderboard-link {
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: bold;
            transition: transform 0.2s, filter 0.2s;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .leaderboard-link:hover {
            transform: scale(1.1);
        }

        .clipboard-icon {
            color: var(--primary-color);
            filter: drop-shadow(0 0 8px rgba(57, 255, 20, 0.6));
            transition: all 0.2s ease;
        }

        .leaderboard-link:hover .clipboard-icon {
            color: var(--secondary-color);
            filter: drop-shadow(0 0 12px rgba(255, 16, 240, 0.8));
            transform: scale(1.05);
        }

        header h1 {
            color: var(--primary-color);
            font-size: 1.5rem;
            text-shadow: 0 0 10px rgba(57, 255, 20, 0.7);
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, text-shadow 0.2s;
        }

        header h1:hover {
            transform: scale(1.05);
            text-shadow: 0 0 15px rgba(57, 255, 20, 0.9);
        }

        .user-info {
            display: flex;
            align-items: center;
        }

        /* Profile picture styles */
        .profile-pic {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: var(--background-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: 0 0 8px rgba(57, 255, 20, 0.7);
            cursor: pointer;
            transition: transform 0.2s;
            overflow: hidden;
        }

        .profile-pic:hover {
            transform: scale(1.1);
        }

        .profile-pic-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
            cursor: pointer;
        }

        .profile-pic-initial {
            font-weight: bold;
            cursor: pointer;
        }

        .post-profile-pic {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            color: var(--background-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
            box-shadow: 0 0 8px rgba(255, 16, 240, 0.7);
            cursor: pointer;
            transition: transform 0.2s;
            overflow: hidden;
        }

        .post-profile-pic:hover {
            transform: scale(1.1);
        }

        .post-profile-pic-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
            cursor: pointer;
        }

        .post-profile-pic-initial {
            font-weight: bold;
            font-size: 1.2rem;
            cursor: pointer;
        }

        .container {
            max-width: 600px;
            margin: 80px auto 20px;
            padding: 0 1rem;
        }

        .post-form {
            background-color: var(--card-bg);
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(57, 255, 20, 0.3);
            margin-bottom: 2rem;
            border: 1px solid var(--primary-color);
        }

        .post-form textarea {
            width: 100%;
            padding: 0.8rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            resize: none;
            margin-bottom: 1rem;
            font-size: 1rem;
            background-color: #222222;
            color: var(--text-color);
        }

        .form-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .media-upload {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .image-upload, .video-upload {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--secondary-color);
            cursor: pointer;
        }

        .image-upload input, .video-upload input {
            display: none;
        }

        .media-preview {
            margin-top: 1rem;
            display: none;
            position: relative;
        }

        .media-preview img {
            max-width: 100%;
            max-height: 200px;
            border-radius: 4px;
        }

        .media-preview video {
            max-width: 100%;
            max-height: 200px;
            border-radius: 4px;
        }

        .media-preview button {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: rgba(255, 255, 255, 0.7);
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }

        .video-duration {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        button.post-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.6rem 1.2rem;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.7);
        }

        button.post-btn:hover {
            background-color: #2aee05;
        }

        .feed {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .post-card {
            background-color: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(255, 16, 240, 0.2);
            overflow: hidden;
            position: relative;
            transition: transform 0.3s ease;
            touch-action: pan-x;
            border: 1px solid var(--secondary-color);
        }

        .post-header {
            display: flex;
            align-items: center;
            padding: 1rem;
            gap: 0.8rem;
        }

        .post-author {
            font-weight: 600;
            color: var(--secondary-color);
            cursor: pointer;
            transition: color 0.2s;
        }

        .post-author:hover {
            color: var(--primary-color);
        }

        .post-time {
            font-size: 0.8rem;
            color: var(--secondary-text);
        }

        .post-content {
            padding: 0 1rem 1rem;
        }

        .post-content p {
            margin-bottom: 1rem;
            line-height: 1.5;
            color: var(--text-color);
        }

        .post-image {
            width: 100%;
            max-height: 400px;
            object-fit: cover;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .post-image:hover {
            opacity: 0.9;
        }

        .post-video {
            width: 100%;
            max-height: 400px;
            border-radius: 4px;
        }

        /* YouTube embed styles */
        .youtube-embed-container {
            margin: 0.5rem 0;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .youtube-embed-container iframe {
            border-radius: 8px;
        }

        .post-stats {
            display: flex;
            justify-content: space-between;
            padding: 0.8rem 1rem;
            border-top: 1px solid var(--border-color);
            font-size: 0.9rem;
            color: #666;
        }
        
        .post-actions {
            display: flex;
            justify-content: space-around;
            padding: 0.5rem;
            border-top: 1px solid var(--border-color);
        }
        
        .post-action-btn {
            background: none;
            border: none;
            padding: 0.5rem;
            cursor: pointer;
            color: var(--secondary-color);
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            transition: color 0.2s;
        }
        
        .post-action-btn:hover {
            color: var(--primary-color);
        }
        
        .comments-section {
            padding: 0 1rem 1rem;
            border-top: 1px solid var(--border-color);
            max-height: 500px;
            overflow-y: auto;
        }
        
        .comment-form {
            display: flex;
            margin: 1rem 0;
            gap: 0.5rem;
        }
        
        .comment-form input {
            flex: 1;
            padding: 0.7rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.9rem;
            background-color: #222222;
            color: var(--text-color);
        }
        
        .comment-form button {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 0 1rem;
            border-radius: 4px;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(255, 16, 240, 0.6);
        }
        
        .comment {
            padding: 0.8rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .comment:last-child {
            border-bottom: none;
        }
        
        .comment-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.3rem;
        }
        
        .comment-author {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--secondary-color);
            cursor: pointer;
            transition: color 0.2s;
        }

        .comment-author:hover {
            color: var(--primary-color);
        }
        
        .comment-time {
            font-size: 0.8rem;
            color: var(--secondary-text);
        }
        
        .comment-text {
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .thread-toggle {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            cursor: pointer;
            font-size: 0.85rem;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }
        
        .thread-toggle:hover {
            color: var(--secondary-color);
        }
        
        .thread-toggle-icon {
            transition: transform 0.2s;
        }
        
        .thread-toggle-icon.open {
            transform: rotate(90deg);
        }
        
        .thread-replies {
            margin-left: 1.5rem;
            padding-left: 0.5rem;
            border-left: 2px solid var(--secondary-color);
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .thread-replies.open {
            max-height: 500px;
            overflow-y: auto;
        }
        
        .reply-form {
            display: flex;
            margin: 0.5rem 0;
            gap: 0.5rem;
        }
        
        .reply-form input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.85rem;
            background-color: #222222;
            color: var(--text-color);
        }
        
        .reply-form button {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 0 0.8rem;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(255, 16, 240, 0.5);
        }

        .swipe-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 10;
            pointer-events: none;
        }

        .swipe-icon {
            font-size: 3rem;
            color: white;
        }

        .like-overlay {
            background-color: rgba(57, 255, 20, 0.5);
        }

        .dislike-overlay {
            background-color: rgba(255, 16, 240, 0.5);
        }

        .auth-container {
            background-color: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 0 25px rgba(57, 255, 20, 0.3), 0 0 15px rgba(255, 16, 240, 0.2);
            padding: 2rem;
            max-width: 400px;
            margin: 100px auto;
            border: 2px solid var(--primary-color);
        }

        .auth-container h2 {
            margin-bottom: 1.5rem;
            text-align: center;
            color: var(--secondary-color);
        }

        .form-group {
            margin-bottom: 1.2rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--primary-color);
        }

        .form-group input {
            width: 100%;
            padding: 0.8rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 1rem;
            background-color: #222222;
            color: var(--text-color);
        }

        .auth-btn {
            width: 50%;
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.8rem;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            margin: 1rem auto 0;
            display: block;
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.7);
        }

        .auth-toggle {
            text-align: center;
            margin-top: 1.5rem;
        }

        .auth-toggle a {
            color: var(--secondary-color);
            text-decoration: none;
            font-weight: 500;
        }

        /* Profile Modal Styles */
        .profile-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .profile-content {
            background-color: var(--card-bg);
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(57, 255, 20, 0.3), 0 0 20px rgba(255, 16, 240, 0.2);
            border: 2px solid var(--primary-color);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .profile-header {
            padding: 2rem;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            background: linear-gradient(135deg, rgba(57, 255, 20, 0.1), rgba(255, 16, 240, 0.1));
        }

        .profile-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            color: var(--background-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 2rem;
            margin: 0 auto 1rem;
            box-shadow: 0 0 15px rgba(255, 16, 240, 0.7);
            overflow: hidden;
            position: relative;
        }

        .profile-avatar-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
            cursor: pointer;
        }

        .profile-avatar-initial {
            font-weight: bold;
            font-size: 2rem;
            cursor: pointer;
        }

        .change-photo-container {
            position: relative;
            display: inline-block;
        }

        .change-photo-btn {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 24px;
            height: 24px;
            background-color: var(--primary-color);
            border: 2px solid var(--background-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            color: var(--background-color);
            box-shadow: 0 0 8px rgba(57, 255, 20, 0.7);
            transition: transform 0.2s;
        }

        .change-photo-btn:hover {
            transform: scale(1.1);
        }

        .photo-upload-input {
            display: none;
        }

        .photo-preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
        }

        .photo-preview-container {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 2rem;
            border: 2px solid var(--primary-color);
            box-shadow: 0 0 30px rgba(57, 255, 20, 0.3);
            text-align: center;
        }

        .photo-preview {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 1rem;
            border: 2px solid var(--secondary-color);
            box-shadow: 0 0 15px rgba(255, 16, 240, 0.7);
        }

        .photo-preview-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .photo-preview-btn {
            padding: 0.8rem 1.5rem;
            border: none;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .photo-save-btn {
            background-color: var(--primary-color);
            color: white;
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.7);
        }

        .photo-cancel-btn {
            background-color: transparent;
            color: var(--secondary-color);
            border: 1px solid var(--secondary-color);
        }

        .profile-username {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }

        .profile-join-date {
            color: var(--secondary-text);
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }

        /* Updated profile controls container */
        .profile-controls {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 1.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .profile-logout-btn {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 0.3rem 0.8rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background-color 0.2s;
            box-shadow: 0 0 5px rgba(255, 16, 240, 0.5);
        }

        .profile-logout-btn:hover {
            background-color: #e60fdb;
        }

        /* Updated filter toggle styles for vertical display */
        .filter-toggle-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .filter-toggle-label {
            font-size: 0.8rem;
            color: var(--text-color);
            font-weight: 500;
            white-space: nowrap;
            text-align: center;
        }

        .profile-stats {
            display: flex;
            justify-content: center;
            padding: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            background-color: rgba(17, 17, 17, 0.5);
        }

        .stat {
            text-align: center;
        }

        .stat-number {
            font-size: 1.3rem;
            font-weight: bold;
            color: var(--primary-color);
            display: block;
        }

        .stat-label {
            font-size: 1.3rem;
            color: var(--secondary-text);
            letter-spacing: 0.5px;
            font-weight: bold;
        }

        .alternating-text .green {
            color: var(--primary-color);
            text-shadow: 0 0 6px rgba(57, 255, 20, 0.6);
        }

        .alternating-text .purple {
            color: var(--secondary-color);
            text-shadow: 0 0 6px rgba(255, 16, 240, 0.6);
        }

        /* Toggle Switch Styles */
        .toggle-switch {
            position: relative;
            width: 40px;
            height: 20px;
            background-color: var(--primary-color);
            border-radius: 20px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), 0 0 6px rgba(57, 255, 20, 0.4);
        }

        .toggle-switch.active {
            background-color: var(--secondary-color);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), 0 0 6px rgba(255, 16, 240, 0.4);
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background-color: var(--text-color);
            border-radius: 50%;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(20px);
        }

        .profile-posts {
            padding: 1rem;
        }

        .profile-posts-header {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--secondary-color);
            margin-bottom: 1rem;
            text-align: center;
        }

        .profile-post-card {
            background-color: rgba(17, 17, 17, 0.5);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            position: relative;
        }

        .profile-post-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 16, 240, 0.3);
        }

        .profile-post-delete-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: rgba(255, 16, 240, 0.8);
            border: none;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: background-color 0.2s, transform 0.2s;
            line-height: 1;
        }

        .profile-post-delete-btn:hover {
            background-color: var(--secondary-color);
            transform: scale(1.1);
        }

        .profile-post-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            font-size: 0.8rem;
            color: var(--secondary-text);
        }

        .post-thumbnail {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            object-fit: cover;
            border: 1px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .media-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .profile-post-text {
            color: var(--text-color);
            line-height: 1.4;
            margin-bottom: 0.5rem;
        }

        .profile-post-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.8rem;
            color: var(--secondary-text);
        }

        .profile-post-stat {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .leaderboard-post-card {
            background-color: rgba(17, 17, 17, 0.5);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .leaderboard-post-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(57, 255, 20, 0.3);
        }

        .leaderboard-rank {
            font-size: 2rem;
            font-weight: bold;
            width: 40px;
            text-align: center;
            flex-shrink: 0;
        }

        .leaderboard-rank.rank-1 {
            color: #FFD700; /* Gold */
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
        }

        .leaderboard-rank.rank-2 {
            color: #C0C0C0; /* Silver */
            text-shadow: 0 0 10px rgba(192, 192, 192, 0.7);
        }

        .leaderboard-rank.rank-3 {
            color: #CD7F32; /* Bronze */
            text-shadow: 0 0 10px rgba(205, 127, 50, 0.7);
        }

        .leaderboard-rank.rank-4,
        .leaderboard-rank.rank-5 {
            color: var(--secondary-color);
            text-shadow: 0 0 8px rgba(255, 16, 240, 0.6);
        }

        /* NEW: Extended rank styling for all posts */
        .leaderboard-rank.rank-6,
        .leaderboard-rank.rank-7,
        .leaderboard-rank.rank-8,
        .leaderboard-rank.rank-9,
        .leaderboard-rank.rank-10 {
            color: var(--primary-color);
            text-shadow: 0 0 6px rgba(57, 255, 20, 0.5);
            font-size: 1.8rem;
        }

        .leaderboard-rank.rank-other {
            color: var(--text-color);
            text-shadow: 0 0 4px rgba(255, 255, 255, 0.3);
            font-size: 1.6rem;
        }

        .leaderboard-post-content {
            flex: 1;
            min-width: 0; /* Allow text truncation */
        }

        .leaderboard-post-header {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 0.5rem;
        }

        .leaderboard-post-author {
            font-weight: 600;
            color: var(--secondary-color);
            cursor: pointer;
            transition: color 0.2s;
        }

        .leaderboard-post-author:hover {
            color: var(--primary-color);
        }

        .leaderboard-post-time {
            font-size: 0.8rem;
            color: var(--secondary-text);
        }

        .leaderboard-post-text {
            color: var(--text-color);
            line-height: 1.4;
            margin-bottom: 0.5rem;
        }

        .leaderboard-post-score {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 0.9rem;
            color: var(--secondary-text);
        }

        .leaderboard-score-highlight {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: bold;
            font-size: 1.1rem;
            text-shadow: none;
        }

        /* NEW: Leaderboard posts counter */
        .leaderboard-posts-counter {
            text-align: center;
            color: var(--secondary-text);
            font-size: 0.9rem;
            margin-bottom: 1rem;
            padding: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .swipe-right-arrow {
            color: var(--primary-color);
            text-shadow: 0 0 8px rgba(57, 255, 20, 0.8);
            filter: drop-shadow(0 0 4px rgba(57, 255, 20, 0.6));
        }

        .swipe-left-arrow {
            color: var(--secondary-color);
            text-shadow: 0 0 8px rgba(255, 16, 240, 0.8);
            filter: drop-shadow(0 0 4px rgba(255, 16, 240, 0.6));
        }

        .close-profile {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            color: var(--secondary-color);
            font-size: 1.5rem;
            cursor: pointer;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .close-profile:hover {
            background-color: rgba(255, 16, 240, 0.2);
        }

        .no-posts {
            text-align: center;
            color: var(--secondary-text);
            font-style: italic;
            padding: 2rem;
        }

        .hidden {
            display: none !important;
        }

        /* Full Screen Image Modal */
        .fullscreen-image-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            backdrop-filter: blur(5px);
            cursor: pointer;
        }

        .fullscreen-image-modal.hidden {
            display: none !important;
        }

        .fullscreen-image-container {
            position: relative;
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }

        .fullscreen-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(57, 255, 20, 0.3), 0 0 20px rgba(255, 16, 240, 0.2);
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .fullscreen-image:hover {
            opacity: 0.95;
        }

        .fullscreen-close-btn {
            position: absolute;
            top: -50px;
            right: 0;
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 2rem;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s, color 0.2s;
            z-index: 3001;
        }

        .fullscreen-close-btn:hover {
            background-color: rgba(255, 16, 240, 0.2);
            color: var(--secondary-color);
        }

        .fullscreen-loading {
            color: var(--primary-color);
            font-size: 1.2rem;
            text-align: center;
        }

        /* Prevent broken images from showing */
        .fullscreen-image[src=""], .fullscreen-image:not([src]) {
            display: none !important;
        }

        @media (max-width: 600px) {
            .container {
                margin-top: 70px;
            }
            
            header h1 {
                font-size: 1.2rem;
            }

            .leaderboard-link {
                font-size: 0.9rem;
            }

            .clipboard-icon {
                width: 22px;
                height: 22px;
            }

            .header-left {
                gap: 0.5rem;
            }

            .profile-content {
                width: 95%;
                max-height: 85vh;
            }

            .profile-header {
                padding: 1.5rem;
            }

            .profile-avatar {
                width: 60px;
                height: 60px;
                font-size: 1.5rem;
            }

            .profile-stats {
                padding: 1rem;
            }

            .profile-controls {
                gap: 1rem;
                align-items: center;
            }

            .filter-toggle-container {
                gap: 0.3rem;
            }

            .filter-toggle-label {
                font-size: 0.75rem;
            }

            .fullscreen-close-btn {
                top: 10px;
                right: 10px;
            }

            /* Keep leaderboard layout consistent with desktop */
            .leaderboard-post-card {
                padding: 0.8rem;
                gap: 0.8rem;
                /* Maintain horizontal flex layout like desktop */
            }

            .leaderboard-rank {
                font-size: 1.8rem;
                width: 35px;
                /* Keep fixed width for consistent alignment */
            }

            .leaderboard-post-content {
                /* Ensure content takes remaining space */
                flex: 1;
                min-width: 0;
            }

            .leaderboard-post-header {
                gap: 0.6rem;
                margin-bottom: 0.4rem;
            }

            .leaderboard-post-text {
                font-size: 0.9rem;
                margin-bottom: 0.4rem;
            }

            .leaderboard-post-score {
                gap: 0.8rem;
                font-size: 0.8rem;
            }

            /* Make profile pics slightly smaller on mobile but keep layout */
            .leaderboard-post-card .post-profile-pic {
                width: 35px;
                height: 35px;
                font-size: 1rem;
            }

            /* YouTube embeds on mobile */
            .youtube-embed-container {
                margin: 0.5rem 0;
            }
        }
        
        @keyframes highlight {
            0% { background-color: rgba(57, 255, 20, 0.4); }
            100% { background-color: transparent; }
        }
        
        .new-comment {
            animation: highlight 2s ease;
        }
        
        .loading-spinner {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            border: 5px solid rgba(57, 255, 20, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
            z-index: 2000;
        }
        
        @keyframes spin {
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Loading spinner -->
    <div class="loading-spinner" id="loading-spinner"></div>
    
    <!-- Authentication Forms -->
    <div id="auth-forms" class="auth-container">
        <!-- Login Form -->
        <div id="login-form">
            <h2><span style="color: #39FF14;">F</span><span style="color: #FF10F0;">l</span><span style="color: #39FF14;">i</span><span style="color: #FF10F0;">p</span><span style="color: #39FF14;">r</span></h2>
            <BR><BR>
                Flipr app is the new social sharing site.
                <BR><BR>
                Flip right to say, that's nice. 
                <br><br>
                Flip left to say, no way.
                <br><br>
                Post text, pics, videos, and YouTube links. 
                <br><br>
                All content destroyed after 7 days. 
                <br><br>     
            <div class="form-group">
                <label for="login-username">Username</label>
                <input type="text" id="login-username" placeholder="Enter your username">
            </div>
            <div class="form-group">
                <label for="login-password">Password</label>
                <input type="password" id="login-password" placeholder="Enter your password">
            </div>
            <button class="auth-btn" id="login-btn">Sign In</button>
            <div class="auth-toggle">
                <p>Don't have an account? <a href="#" id="show-signup">Sign Up</a></p>
            </div>
        </div>

        <!-- Registration Form -->
        <div id="signup-form" class="hidden">
            <h2><span style="color: #39FF14;">F</span><span style="color: #FF10F0;">l</span><span style="color: #39FF14;">i</span><span style="color: #FF10F0;">p</span><span style="color: #39FF14;">r</span></h2>
            <div class="form-group">
                <label for="signup-username">Username</label>
                <input type="text" id="signup-username" placeholder="Choose a username">
            </div>
            <div class="form-group">
                <label for="signup-email">Email</label>
                <input type="email" id="signup-email" placeholder="Enter your email">
            </div>
            <div class="form-group">
                <label for="signup-password">Password</label>
                <input type="password" id="signup-password" placeholder="Create a password">
            </div>
            <div class="form-group">
                <label for="signup-confirm">Confirm Password</label>
                <input type="password" id="signup-confirm" placeholder="Confirm your password">
            </div>
            <button class="auth-btn" id="signup-btn">Sign Up</button>
            <div class="auth-toggle">
                <p>Already have an account? <a href="#" id="show-login">Sign In</a></p>
            </div>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div id="leaderboard-modal" class="profile-modal hidden">
        <div class="profile-content">
            <button class="close-profile" id="close-leaderboard">Ã—</button>
            <div class="profile-header">
                <div class="profile-username alternating-text" style="font-size: 1.8rem; margin-bottom: 0.5rem;">
                    <span class="green">F</span><span class="purple">l</span><span class="green">i</span><span class="purple">p</span><span class="green">r</span> <span class="purple">L</span><span class="green">e</span><span class="purple">a</span><span class="green">d</span><span class="purple">e</span><span class="green">r</span><span class="purple">b</span><span class="green">o</span><span class="purple">a</span><span class="green">r</span><span class="purple">d</span>
                </div>
                <div class="profile-join-date">All posts ranked by Flipr score</div>
            </div>
            <div class="profile-posts">
                <div id="leaderboard-posts-container">
                    <!-- All posts will be loaded here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Profile Modal -->
    <div id="profile-modal" class="profile-modal hidden">
        <div class="profile-content">
            <button class="close-profile" id="close-profile">Ã—</button>
            <div class="profile-header">
                <div class="change-photo-container">
                    <div class="profile-avatar" id="profile-avatar">A</div>
                    <button class="change-photo-btn" id="change-photo-btn" title="Change photo">ðŸ“·</button>
                    <input type="file" id="photo-upload-input" class="photo-upload-input" accept="image/*">
                </div>
                <div class="profile-username" id="profile-username">Username</div>
                <div class="profile-join-date" id="profile-join-date">Joined January 2024</div>
                <!-- Updated: Controls now on same line -->
                <div class="profile-controls">
                    <button class="profile-logout-btn" id="logout-btn">Logout</button>
                    <div class="filter-toggle-container">
                        <div class="toggle-switch" id="hide-disliked-toggle">
                            <div class="toggle-slider"></div>
                        </div>
                        <label class="filter-toggle-label" for="hide-disliked-toggle">
                            hide left swipes
                        </label>
                    </div>
                </div>
            </div>
            <div class="profile-stats">
                <div class="stat">
                    <span class="stat-number" id="user-score">0</span>
                    <span class="stat-label alternating-text">
                        <span class="green">F</span><span class="purple">l</span><span class="green">i</span><span class="purple">p</span><span class="green">r</span> <span class="purple">s</span><span class="green">c</span><span class="purple">o</span><span class="green">r</span><span class="purple">e</span>
                    </span>
                </div>
            </div>
            <div class="profile-posts">
                <div id="user-posts-container">
                    <!-- User posts will be loaded here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Photo Preview Modal -->
    <div id="photo-preview-modal" class="photo-preview-modal hidden">
        <div class="photo-preview-container">
            <h3 style="color: var(--primary-color); margin-bottom: 1rem;">Preview Profile Photo</h3>
            <img id="photo-preview" class="photo-preview" src="" alt="Preview">
            <div class="photo-preview-actions">
                <button class="photo-preview-btn photo-save-btn" id="save-photo-btn">Save Photo</button>
                <button class="photo-preview-btn photo-cancel-btn" id="cancel-photo-btn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Full Screen Image Modal -->
    <div id="fullscreen-image-modal" class="fullscreen-image-modal hidden">
        <div class="fullscreen-image-container">
            <button class="fullscreen-close-btn" id="fullscreen-close-btn" title="Close">Ã—</button>
            <img id="fullscreen-image" class="fullscreen-image" style="display: none;" alt="">
        </div>
    </div>

    <!-- Main App Interface (Initially Hidden) -->
    <div id="app-interface" class="hidden">
        <header>
            <div class="header-left">
                <h1><span style="color: #39FF14;">F</span><span style="color: #FF10F0;">l</span><span style="color: #39FF14;">i</span><span style="color: #FF10F0;">p</span><span style="color: #39FF14;">r</span></h1>
                <div id="leaderboard-link" class="leaderboard-link">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="clipboard-icon">
                        <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
                        <rect x="8" y="2" width="8" height="4" rx="1" ry="1"/>
                        <path d="M9 12h6"/>
                        <path d="M9 16h6"/>
                    </svg>
                </div>
            </div>
            <div class="user-info">
                <div id="user-profile-pic" class="profile-pic">A</div>
            </div>
        </header>

        <div class="container">
            <!-- Post Form -->
            <div class="post-form">
                <textarea id="post-text" placeholder="What's on your mind?" rows="3"></textarea>
                
                <!-- Media Preview (for both images and videos) -->
                <div class="media-preview" id="image-preview">
                    <img id="preview-img" src="" alt="">
                    <button id="remove-image">Ã—</button>
                </div>
                
                <div class="media-preview" id="video-preview">
                    <video id="preview-video" controls></video>
                    <span class="video-duration" id="video-duration">00:00</span>
                    <button id="remove-video">Ã—</button>
                </div>
                
                <div class="form-actions">
                    <div class="media-upload">
                        <label class="image-upload">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                <circle cx="8.5" cy="8.5" r="1.5"/>
                                <polyline points="21 15 16 10 5 21"/>
                            </svg>
                            <input type="file" id="image-input" accept="image/*">
                        </label>
                        <label class="video-upload">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polygon points="23 7 16 12 23 17 23 7"/>
                                <rect x="1" y="5" width="15" height="14" rx="2" ry="2"/>
                            </svg>
                            <input type="file" id="video-input" accept="video/*">
                        </label>
                    </div>
                    <button class="post-btn" id="submit-post">Post</button>
                </div>
            </div>

            <!-- Posts Feed -->
            <div class="feed" id="posts-feed" style="display: flex; min-height: 100px;">
                <!-- Current post will be shown here -->
            </div>
        </div>
    </div>

    <script>
        // Firebase Configuration
        const firebaseConfig = {
            // REPLACE WITH YOUR FIREBASE CONFIG
            apiKey: "AIzaSyCq6jnPC__yN158gIq5oBsdzM7-ypnK2aU",
            authDomain: "flipr-a9cbf.firebaseapp.com",
            databaseURL: "https://flipr-a9cbf-default-rtdb.firebaseio.com/",
            projectId: "flipr-a9cbf",
            storageBucket: "flipr-a9cbf.firebasestorage.app",
            messagingSenderId: "558454333887",
            appId: "1:558454333887:web:b45b37516a37c27e4ac10a"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        
        // Firebase References
        const auth = firebase.auth();
        const database = firebase.database();
        const storage = firebase.storage();
        const postsRef = database.ref('posts');
        const usersRef = database.ref('users');
        const storageRef = storage.ref();
        
        // DOM Elements
        const authForms = document.getElementById('auth-forms');
        const loginForm = document.getElementById('login-form');
        const signupForm = document.getElementById('signup-form');
        const showSignupLink = document.getElementById('show-signup');
        const showLoginLink = document.getElementById('show-login');
        const appInterface = document.getElementById('app-interface');
        const userProfilePic = document.getElementById('user-profile-pic');
        const postTextarea = document.getElementById('post-text');
        const imageInput = document.getElementById('image-input');
        const videoInput = document.getElementById('video-input');
        const imagePreview = document.getElementById('image-preview');
        const videoPreview = document.getElementById('video-preview');
        const previewImg = document.getElementById('preview-img');
        const previewVideo = document.getElementById('preview-video');
        const videoDuration = document.getElementById('video-duration');
        const removeImageBtn = document.getElementById('remove-image');
        const removeVideoBtn = document.getElementById('remove-video');
        const submitPostBtn = document.getElementById('submit-post');
        const postsFeed = document.getElementById('posts-feed');
        const loadingSpinner = document.getElementById('loading-spinner');
        const logoElement = document.querySelector('header h1');
        
        // Profile Modal Elements
        const profileModal = document.getElementById('profile-modal');
        const closeProfileBtn = document.getElementById('close-profile');
        const profileAvatar = document.getElementById('profile-avatar');
        const profileUsername = document.getElementById('profile-username');
        const profileJoinDate = document.getElementById('profile-join-date');
        const userScore = document.getElementById('user-score');
        const userPostsContainer = document.getElementById('user-posts-container');
        
        // Leaderboard Modal Elements
        const leaderboardModal = document.getElementById('leaderboard-modal');
        const leaderboardLink = document.getElementById('leaderboard-link');
        const closeLeaderboardBtn = document.getElementById('close-leaderboard');
        const leaderboardPostsContainer = document.getElementById('leaderboard-posts-container');
        
        // NEW: Filter Toggle Elements
        const hideDislikedToggle = document.getElementById('hide-disliked-toggle');
        let hideDislikedPosts = false; // Filter state
        
        // Photo Upload Elements
        const changePhotoBtn = document.getElementById('change-photo-btn');
        const photoUploadInput = document.getElementById('photo-upload-input');
        const photoPreviewModal = document.getElementById('photo-preview-modal');
        const photoPreview = document.getElementById('photo-preview');
        const savePhotoBtn = document.getElementById('save-photo-btn');
        const cancelPhotoBtn = document.getElementById('cancel-photo-btn');
        
        // Full Screen Image Modal Elements
        const fullscreenImageModal = document.getElementById('fullscreen-image-modal');
        const fullscreenImage = document.getElementById('fullscreen-image');
        const fullscreenCloseBtn = document.getElementById('fullscreen-close-btn');
        
        // Photo upload state
        let selectedPhotoFile = null;
        
        // Cache for user profile pictures to avoid repeated Firebase calls
        const profilePictureCache = new Map();
        
        // NEW: Cache for user's disliked posts
        let userDislikedPosts = new Set();
        
        // Media type tracking
        let activeMediaType = null; // 'image', 'video', or null
        
        // For video format support testing
        const testVideoElement = document.createElement('video');
        
        // Function to check if a specific video format is supported
        function isVideoFormatSupported(mimeType) {
            return testVideoElement.canPlayType(mimeType) !== '';
        }
        
        // SIMPLIFIED QUEUE-BASED APPROACH: Separate ranking from navigation
        let allPosts = [];                    // Master array of all posts (always kept sorted)
        let viewingQueue = [];                // Queue of posts to show user
        let currentPost = null;               // Currently displayed post
        let currentCycleIndex = 0;            // Index in current cycle through all posts
        let recentlyDisliked = new Set();     // Recently disliked posts (temporary filter)
        let queueVersion = 0;                 // Version number to track queue rebuilds
        
        // Current user data
        let currentUser = null;
        
        // Ensure fullscreen modal is properly hidden on startup
        document.addEventListener('DOMContentLoaded', function() {
            const modal = document.getElementById('fullscreen-image-modal');
            const image = document.getElementById('fullscreen-image');
            if (modal) modal.classList.add('hidden');
            if (image) {
                image.style.display = 'none';
                image.removeAttribute('src');
                image.alt = '';
            }
        });
        
        // Enhanced error handling for Firebase security rules
        function handleFirebaseError(error) {
            console.error('Firebase operation failed:', error);
            
            switch (error.code) {
                case 'PERMISSION_DENIED':
                    alert('You don\'t have permission to perform this action.');
                    break;
                case 'UNAUTHENTICATED':
                    alert('Please log in to continue.');
                    showAuthForms();
                    break;
                case 'INVALID_DATA':
                    alert('The data you\'re trying to save is invalid.');
                    break;
                default:
                    alert('An error occurred. Please try again.');
            }
        }
        
        // Password strength validation
        function validatePassword(password) {
            const errors = [];
            
            if (password.length < 8) {
                errors.push('at least 8 characters');
            }
            
            if (!/[A-Z]/.test(password)) {
                errors.push('one uppercase letter');
            }
            
            if (!/[a-z]/.test(password)) {
                errors.push('one lowercase letter');
            }
            
            if (!/\d/.test(password)) {
                errors.push('one number');
            }
            
            if (!/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
                errors.push('one special character (!@#$%^&*(),.?":{}|<>)');
            }
            
            if (errors.length > 0) {
                throw new Error('Password must contain ' + errors.join(', '));
            }
            
            return true;
        }
        
        // Show loading spinner
        function showLoading() {
            loadingSpinner.style.display = 'block';
        }
        
        // Hide loading spinner
        function hideLoading() {
            loadingSpinner.style.display = 'none';
        }
        
        // Show Auth Forms
        function showAuthForms() {
            appInterface.classList.add('hidden');
            authForms.classList.remove('hidden');
            loginForm.classList.remove('hidden');
            signupForm.classList.add('hidden');
        }
        
        // Function to get the first initial from a username
        function getInitial(username) {
            if (!username) return '?';
            return username.charAt(0).toUpperCase();
        }

        // Function to create profile picture HTML
        function createProfilePicHTML(user, className = 'profile-pic') {
            if (user.profilePicture) {
                return `<img src="${user.profilePicture}" alt="${user.username || ''}" class="${className}-image">`;
            } else {
                const initial = getInitial(user.username || user.author || '');
                return `<div class="${className}-initial">${initial}</div>`;
            }
        }

        // Function to update profile picture display
        function updateProfilePicture(element, user, className = 'profile-pic') {
            // Add data attributes for profile clicking
            element.setAttribute('data-user-id', user.uid || user.authorId || '');
            element.setAttribute('data-username', user.username || user.author || '');
            
            if (user.profilePicture) {
                element.innerHTML = `<img src="${user.profilePicture}" alt="${user.username || ''}" class="${className}-image">`;
            } else {
                const initial = getInitial(user.username || user.author || '');
                element.innerHTML = `<div class="${className}-initial">${initial}</div>`;
            }
        }

        // Helper function to extract YouTube video ID from URL
        function extractYouTubeId(url) {
            if (!url) return null;
            
            // YouTube URL patterns
            const patterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
                /youtube\.com\/watch\?.*v=([a-zA-Z0-9_-]{11})/
            ];
            
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) {
                    return match[1];
                }
            }
            return null;
        }

        // Helper function to detect YouTube URLs in text and extract them
        function extractYouTubeFromText(text) {
            if (!text) return { cleanText: text, youtubeId: null, youtubeUrl: null };
            
            // YouTube URL patterns - more comprehensive
            const youtubePattern = /(https?:\/\/)?(www\.)?(youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})(\S*)?/gi;
            
            let youtubeUrl = null;
            let youtubeId = null;
            
            // Find the first YouTube URL
            const match = text.match(youtubePattern);
            if (match && match[0]) {
                youtubeUrl = match[0];
                youtubeId = extractYouTubeId(youtubeUrl);
                
                // Remove the YouTube URL from the text
                const cleanText = text.replace(youtubePattern, '').trim();
                
                return { cleanText, youtubeId, youtubeUrl };
            }
            
            return { cleanText: text, youtubeId: null, youtubeUrl: null };
        }

        // Helper function to make URLs clickable in text (excluding YouTube URLs which become embeds) and preserve line breaks
        function linkifyText(text) {
            if (!text) return '';
            
            // First remove any YouTube URLs since they'll be handled as embeds
            const textWithoutYoutube = text.replace(/(https?:\/\/)?(www\.)?(youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})(\S*)?/gi, '');
            
            // URL regex pattern that matches http, https, www, and basic domain patterns
            const urlPattern = /(https?:\/\/[^\s]+)|(www\.[^\s]+)|([a-zA-Z0-9-]+\.[a-zA-Z]{2,}(?:\/[^\s]*)?)/g;
            
            // First convert URLs to clickable links
            let processedText = textWithoutYoutube.replace(urlPattern, function(match) {
                let url = match;
                
                // Add protocol if missing
                if (!url.startsWith('http://') && !url.startsWith('https://')) {
                    url = 'https://' + url;
                }
                
                // Create clickable link with security attributes
                return `<a href="${url}" target="_blank" rel="noopener noreferrer" style="color: var(--primary-color); text-decoration: underline;">${match}</a>`;
            });
            
            // Then convert line breaks to <br> tags
            processedText = processedText.replace(/\n/g, '<br>');
            
            return processedText;
        }

        // NEW: Refresh user's disliked posts cache from Firebase
        function refreshUserDislikedPosts() {
            if (!currentUser) return Promise.resolve();
            
            return loadUserDislikedPosts(currentUser.uid).then(dislikedPosts => {
                const oldCount = userDislikedPosts.size;
                userDislikedPosts = dislikedPosts;
                const newCount = userDislikedPosts.size;
                
                console.log(`ðŸ”„ Refreshed disliked posts cache: ${oldCount} â†’ ${newCount}`);
                return dislikedPosts;
            });
        }
        async function loadUserDislikedPosts(userId) {
            if (!userId) return new Set();
            
            try {
                const snapshot = await usersRef.child(`${userId}/dislikedPosts`).once('value');
                const dislikedData = snapshot.val() || {};
                
                // Only include posts where the value is true (filter out null/deleted entries)
                const currentlyDislikedPosts = Object.keys(dislikedData).filter(postId => dislikedData[postId] === true);
                
                console.log(`ðŸ“‹ Loaded ${currentlyDislikedPosts.length} currently disliked posts (filtered from ${Object.keys(dislikedData).length} total entries)`);
                return new Set(currentlyDislikedPosts);
            } catch (error) {
                console.error('Error loading user disliked posts:', error);
                return new Set();
            }
        }

        // NEW: Save toggle setting to user profile
        function saveHideDislikedSetting(enabled) {
            if (!currentUser) return;
            
            usersRef.child(`${currentUser.uid}/hideDislikedPosts`).set(enabled)
                .then(() => {
                    console.log('ðŸ’¾ Hide disliked posts setting saved:', enabled);
                })
                .catch((error) => {
                    console.error('Error saving hide disliked posts setting:', error);
                });
        }

        // NEW: Load toggle setting from user profile
        async function loadHideDislikedSetting(userId) {
            if (!userId) return false;
            
            try {
                const snapshot = await usersRef.child(`${userId}/hideDislikedPosts`).once('value');
                const setting = snapshot.val();
                return setting === true; // Default to false if not set
            } catch (error) {
                console.error('Error loading hide disliked posts setting:', error);
                return false;
            }
        }

        // NEW: Apply toggle setting to UI and logic
        function applyHideDislikedSetting(enabled) {
            hideDislikedPosts = enabled;
            
            // Update toggle visual state
            if (enabled) {
                hideDislikedToggle.classList.add('active');
            } else {
                hideDislikedToggle.classList.remove('active');
            }
            
            console.log('ðŸ”§ Hide disliked posts setting applied:', enabled);
            
            // Refresh the main feed to apply the filter
            refreshViewingQueue();
            if (allPosts.length > 0) {
                showNextPost();
            }
        }

        // NEW: Function to check if user has disliked a specific post
        function hasUserDislikedPost(postId) {
            return userDislikedPosts.has(postId);
        }

        // NEW: Function to open a specific post in the feed
        function openPostInFeed(postId) {
            console.log('ðŸŽ¯ Opening post in feed:', postId);
            
            // Find the post in allPosts array
            const post = allPosts.find(p => p.id === postId);
            
            if (!post) {
                console.error('âŒ Post not found in allPosts array:', postId);
                alert('Post not found');
                return;
            }
            
            // Close all modals
            closeProfile();
            closeLeaderboard();
            
            // Set this post as the current post
            currentPost = post;
            
            // Display the post
            displayCurrentPost();
            
            console.log('âœ… Post opened in feed:', post.author);
        }

        // NEW: Toggle filter for hiding disliked posts (MAIN FEED ONLY) - with persistence
        function toggleHideDislikedPosts() {
            hideDislikedPosts = !hideDislikedPosts;
            
            // Update toggle visual state
            if (hideDislikedPosts) {
                hideDislikedToggle.classList.add('active');
            } else {
                hideDislikedToggle.classList.remove('active');
            }
            
            console.log('ðŸ”§ Hide disliked posts toggled:', hideDislikedPosts);
            
            // Save the setting to user profile for persistence
            saveHideDislikedSetting(hideDislikedPosts);
            
            // Refresh the main feed to apply/remove the filter
            // This ONLY affects the main swipe feed, NOT profile posts
            refreshViewingQueue();
            showNextPost();
        }

        // Profile Modal Functions
        function showProfile(userId, username) {
            console.log('ðŸ‘¤ Showing profile for:', username, userId);
            showLoading();
            
            // Set basic profile info
            profileUsername.textContent = username;
            
            // Show/hide change photo button and logout button based on whether this is the current user's profile
            const isOwnProfile = currentUser && userId === currentUser.uid;
            changePhotoBtn.style.display = isOwnProfile ? 'flex' : 'none';
            
            // Show/hide logout button and toggle - only show on user's own profile
            const logoutBtn = document.getElementById('logout-btn');
            const profileControls = document.querySelector('.profile-controls');
            if (logoutBtn) {
                logoutBtn.style.display = isOwnProfile ? 'block' : 'none';
            }
            if (profileControls) {
                profileControls.style.display = isOwnProfile ? 'flex' : 'none';
            }
            
            // Get user data and posts
            Promise.all([
                getUserData(userId),
                getUserPosts(userId)
            ]).then(([userData, userPosts]) => {
                // Update profile avatar
                const userForDisplay = {
                    uid: userId,
                    username: username,
                    profilePicture: userData ? userData.profilePicture : null
                };
                updateProfilePicture(profileAvatar, userForDisplay, 'profile-avatar');
                
                displayUserProfile(userData, userPosts, userId);
                profileModal.classList.remove('hidden');
                hideLoading();
            }).catch(error => {
                console.error('Error loading profile:', error);
                alert('Error loading profile');
                hideLoading();
            });
        }

        function getUserData(userId) {
            return usersRef.child(userId).once('value').then(snapshot => {
                return snapshot.val();
            });
        }

        function getUserPosts(userId) {
            return postsRef.orderByChild('authorId').equalTo(userId).once('value').then(snapshot => {
                const posts = [];
                snapshot.forEach(child => {
                    posts.push(child.val());
                });
                return posts.reverse(); // Most recent first
            });
        }

        // Profile display function - NO filtering based on toggle
        async function displayUserProfile(userData, userPosts, userId) {
            // Set join date
            if (userData && userData.createdAt) {
                const joinDate = new Date(userData.createdAt);
                profileJoinDate.textContent = `Joined ${joinDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}`;
            } else {
                profileJoinDate.textContent = 'Member since 2024';
            }

            // Always show ALL posts in profile - no filtering based on dislike toggle
            const postsToDisplay = userPosts;

            // Calculate total score based on ALL posts
            let totalScore = 0;
            postsToDisplay.forEach(post => {
                const likes = post.likes || 0;
                const dislikes = post.dislikes || 0;
                totalScore += (likes - dislikes);
            });

            // Update score
            userScore.textContent = totalScore;

            // Display all posts
            displayUserPosts(postsToDisplay, currentUser && userId === currentUser.uid);
        }

        function displayUserPosts(posts, isOwnProfile = false) {
            userPostsContainer.innerHTML = '';

            if (posts.length === 0) {
                userPostsContainer.innerHTML = '<div class="no-posts">No posts yet</div>';
                return;
            }

            posts.slice(0, 10).forEach(post => { // Show max 10 posts
                const postElement = createProfilePostElement(post, isOwnProfile);
                userPostsContainer.appendChild(postElement);
            });
        }

        function createProfilePostElement(post, isOwnProfile = false) {
            const postElement = document.createElement('div');
            postElement.className = 'profile-post-card';
            // Add data attribute to identify this as a clickable profile post
            postElement.setAttribute('data-post-id', post.id);

            const postDate = new Date(post.timestamp);
            const timeAgo = getTimeAgo(postDate);
            
            const likes = post.likes || 0;
            const dislikes = post.dislikes || 0;
            const score = likes - dislikes;
            const comments = post.comments ? Object.keys(post.comments).length : 0;

            // Truncate text if too long
            let displayText = post.text || '';
            if (displayText.length > 150) {
                displayText = displayText.substring(0, 150) + '...';
            }

            let mediaIndicator = '';
            if (post.youtubeId) {
                // For YouTube posts - show thumbnail
                mediaIndicator = `
                    <div class="media-indicator">
                        <div style="position: relative; display: inline-block;">
                            <img src="https://img.youtube.com/vi/${post.youtubeId}/mqdefault.jpg" alt="YouTube thumbnail" class="post-thumbnail" style="background-color: #333;">
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                                       color: white; font-size: 16px; text-shadow: 0 0 4px rgba(0,0,0,0.8);">â–¶</div>
                            <div style="position: absolute; bottom: 2px; right: 2px; background: rgba(255,0,0,0.8); 
                                       color: white; font-size: 8px; padding: 1px 3px; border-radius: 2px; font-weight: bold;">YT</div>
                        </div>
                    </div>
                `;
            } else if (post.videoURL) {
                // For video posts with autoplay
                mediaIndicator = `
                    <div class="media-indicator">
                        <div style="position: relative; display: inline-block;">
                            <div class="video-thumbnail-container" data-video-url="${post.videoURL}">
                                <div class="post-thumbnail" style="background-color: #333; display: flex; align-items: center; justify-content: center; color: var(--primary-color);">
                                    ðŸ“¹
                                </div>
                                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                                           color: white; font-size: 12px; text-shadow: 0 0 4px rgba(0,0,0,0.8);">â–¶</div>
                            </div>
                        </div>
                    </div>
                `;
            } else if (post.image && post.image.trim() !== '') {
                mediaIndicator = `<div class="media-indicator"><img src="${post.image}" alt="Post thumbnail" class="post-thumbnail"></div>`;
            }

            // Add delete button if this is the user's own profile
            const deleteButton = isOwnProfile ? `
                <button class="profile-post-delete-btn" data-post-id="${post.id}" title="Delete post">
                    Ã—
                </button>
            ` : '';

            postElement.innerHTML = `
                ${deleteButton}
                <div class="profile-post-meta">
                    <span>${timeAgo}</span>
                    ${mediaIndicator}
                </div>
                <div class="profile-post-text">${linkifyText(displayText)}</div>
                <div class="profile-post-stats">
                    <div class="profile-post-stat">
                        <span class="swipe-left-arrow">â†</span>
                        <span>${dislikes}</span>
                    </div>
                    <div class="profile-post-stat">
                        <span class="swipe-right-arrow">â†’</span>
                        <span>${likes}</span>
                    </div>
                    <div class="profile-post-stat">
                        <span>ðŸ’¬</span>
                        <span>${comments}</span>
                    </div>
                    <div class="profile-post-stat">
                        <span style="color: ${score >= 0 ? 'var(--primary-color)' : 'var(--secondary-color)'}">âš¡ ${score}</span>
                    </div>
                </div>
            `;

            // Generate video thumbnail after element is created
            if (post.videoURL) {
                setTimeout(() => {
                    generateVideoThumbnail(post.videoURL, postElement.querySelector('.video-thumbnail-container'));
                }, 100);
            }

            return postElement;
        }

        // Function to generate video thumbnail on-demand
        function generateVideoThumbnail(videoUrl, container) {
            if (!container) return;
            
            const video = document.createElement('video');
            video.crossOrigin = 'anonymous';
            video.muted = true;
            video.style.display = 'none';
            
            video.onloadeddata = function() {
                try {
                    // Seek to 1 second in or 10% of duration, whichever is smaller
                    const seekTime = Math.min(1, video.duration * 0.1);
                    video.currentTime = seekTime;
                } catch (error) {
                    console.warn('Could not seek video for thumbnail:', error);
                }
            };
            
            video.onseeked = function() {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = 40;
                    canvas.height = 40;
                    const ctx = canvas.getContext('2d');
                    
                    // Draw video frame to canvas
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    // Convert to data URL
                    const thumbnailData = canvas.toDataURL('image/jpeg', 0.8);
                    
                    // Update the container with the actual thumbnail
                    const thumbnailElement = container.querySelector('.post-thumbnail');
                    if (thumbnailElement && thumbnailData !== 'data:,') {
                        thumbnailElement.style.backgroundImage = `url(${thumbnailData})`;
                        thumbnailElement.style.backgroundSize = 'cover';
                        thumbnailElement.style.backgroundPosition = 'center';
                        thumbnailElement.innerHTML = ''; // Remove the ðŸ“¹ icon
                    }
                } catch (error) {
                    console.warn('Could not generate video thumbnail:', error);
                    // Keep the default ðŸ“¹ icon
                } finally {
                    // Clean up
                    document.body.removeChild(video);
                }
            };
            
            video.onerror = function() {
                console.warn('Video failed to load for thumbnail generation');
                // Keep the default ðŸ“¹ icon
                try {
                    document.body.removeChild(video);
                } catch (e) {}
            };
            
            // Add to DOM temporarily and load video
            document.body.appendChild(video);
            video.src = videoUrl;
            video.load();
        }

        function closeProfile() {
            profileModal.classList.add('hidden');
            // Restore body scrolling if no other modals are open
            if (fullscreenImageModal.classList.contains('hidden') && photoPreviewModal.classList.contains('hidden') && leaderboardModal.classList.contains('hidden')) {
                document.body.style.overflow = '';
            }
        }

        // Leaderboard Modal Functions
        function showLeaderboard() {
            console.log('ðŸ† Opening leaderboard');
            showLoading();
            
            // Get ALL posts by score (no limit)
            const topPosts = getTopPosts(); // No limit parameter = all posts
            
            if (topPosts.length === 0) {
                leaderboardPostsContainer.innerHTML = '<div class="no-posts">No posts available for leaderboard</div>';
            } else {
                displayLeaderboardPosts(topPosts);
            }
            
            leaderboardModal.classList.remove('hidden');
            hideLoading();
        }

        function closeLeaderboard() {
            leaderboardModal.classList.add('hidden');
            // Restore body scrolling if no other modals are open
            if (fullscreenImageModal.classList.contains('hidden') && photoPreviewModal.classList.contains('hidden') && profileModal.classList.contains('hidden')) {
                document.body.style.overflow = '';
            }
        }

        // UPDATED: Modified to return all posts when no limit is specified
        function getTopPosts(limit = null) {
            // Sort all posts by score (likes - dislikes) in descending order
            const sortedPosts = [...allPosts].sort((a, b) => {
                const scoreA = (a.likes || 0) - (a.dislikes || 0);
                const scoreB = (b.likes || 0) - (b.dislikes || 0);
                return scoreB - scoreA;
            });
            
            // If limit is specified, return only that many posts, otherwise return all
            return limit ? sortedPosts.slice(0, limit) : sortedPosts;
        }

        // UPDATED: Display all leaderboard posts with enhanced ranking
        function displayLeaderboardPosts(posts) {
            leaderboardPostsContainer.innerHTML = '';

            posts.forEach((post, index) => {
                const postElement = createLeaderboardPostElement(post, index + 1);
                leaderboardPostsContainer.appendChild(postElement);
            });
        }

        // UPDATED: Enhanced ranking visual for all posts
        function createLeaderboardPostElement(post, rank) {
            const postElement = document.createElement('div');
            postElement.className = 'leaderboard-post-card';
            postElement.setAttribute('data-post-id', post.id);

            const postDate = new Date(post.timestamp);
            const timeAgo = getTimeAgo(postDate);
            
            const likes = post.likes || 0;
            const dislikes = post.dislikes || 0;
            const score = likes - dislikes;
            const comments = post.comments ? Object.keys(post.comments).length : 0;

            // Truncate text if too long
            let displayText = post.text || '';
            if (displayText.length > 120) {
                displayText = displayText.substring(0, 120) + '...';
            }

            // Determine rank class for styling with extended categories
            let rankClass = '';
            if (rank <= 3) {
                rankClass = `rank-${rank}`; // Gold, Silver, Bronze
            } else if (rank <= 5) {
                rankClass = `rank-${rank}`; // Special styling for 4th and 5th
            } else if (rank <= 10) {
                rankClass = `rank-${rank}`; // Green styling for top 10
            } else {
                rankClass = 'rank-other'; // Default styling for rest
            }

            postElement.innerHTML = `
                <div class="leaderboard-rank ${rankClass}">${rank}</div>
                <div class="post-profile-pic" data-user-id="${post.authorId}" data-username="${post.author}"></div>
                <div class="leaderboard-post-content">
                    <div class="leaderboard-post-header">
                        <span class="leaderboard-post-author" data-user-id="${post.authorId}" data-username="${post.author}">${post.author}</span>
                        <span class="leaderboard-post-time">${timeAgo}</span>
                    </div>
                    <div class="leaderboard-post-text">${linkifyText(displayText)}</div>
                    <div class="leaderboard-post-score">
                        <div class="profile-post-stat">
                            <span class="swipe-left-arrow">â†</span>
                            <span>${dislikes}</span>
                        </div>
                        <div class="profile-post-stat">
                            <span class="swipe-right-arrow">â†’</span>
                            <span>${likes}</span>
                        </div>
                        <div class="profile-post-stat">
                            <span>ðŸ’¬</span>
                            <span>${comments}</span>
                        </div>
                        <div class="profile-post-stat">
                            <span class="leaderboard-score-highlight">âš¡ ${score}</span>
                        </div>
                    </div>
                </div>
            `;

            // Update the profile picture after creating the element
            const profilePicElement = postElement.querySelector('.post-profile-pic');
            fetchAuthorProfilePicture(post.authorId, post.author, profilePicElement);

            return postElement;
        }

        // Photo Upload Functions
        function handlePhotoSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            // Validate file type
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file');
                return;
            }

            // Validate file size (5MB limit)
            if (file.size > 5 * 1024 * 1024) {
                alert('Image is too large. Please select an image smaller than 5MB.');
                return;
            }

            selectedPhotoFile = file;

            // Show preview
            const reader = new FileReader();
            reader.onload = function(event) {
                photoPreview.src = event.target.result;
                photoPreviewModal.classList.remove('hidden');
            };
            reader.readAsDataURL(file);
        }

        function cancelPhotoUpload() {
            selectedPhotoFile = null;
            photoUploadInput.value = '';
            photoPreview.src = '';
            photoPreviewModal.classList.add('hidden');
        }

        function saveProfilePhoto() {
            if (!selectedPhotoFile || !currentUser) {
                alert('Please select a photo first');
                return;
            }

            showLoading();

            // Create unique filename
            const photoFileName = `profile-pics/${currentUser.uid}/${Date.now()}_profile.jpg`;
            const photoRef = storageRef.child(photoFileName);

            // Compress and upload image
            compressImage(selectedPhotoFile, 300, 300, 0.8)
                .then(compressedFile => {
                    return photoRef.put(compressedFile);
                })
                .then(snapshot => {
                    return snapshot.ref.getDownloadURL();
                })
                .then(downloadURL => {
                    // Update user profile in database
                    return usersRef.child(currentUser.uid).update({
                        profilePicture: downloadURL
                    }).then(() => downloadURL);
                })
                .then((downloadURL) => {
                    // Update current user object with the download URL
                    currentUser.profilePicture = downloadURL;
                    
                    // Clear cache for current user to ensure fresh data
                    clearProfileCache(currentUser.uid);
                    
                    // Update all profile displays
                    updateAllProfileDisplays();
                    
                    // Close modals
                    cancelPhotoUpload();
                    hideLoading();
                    
                    alert('Profile photo updated successfully!');
                })
                .catch(error => {
                    console.error('Error uploading profile photo:', error);
                    hideLoading();
                    alert('Error uploading photo. Please try again.');
                });
        }

        // Image compression function
        function compressImage(file, maxWidth, maxHeight, quality) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();

                img.onload = function() {
                    // Calculate new dimensions
                    let { width, height } = img;
                    
                    if (width > height) {
                        if (width > maxWidth) {
                            height = (height * maxWidth) / width;
                            width = maxWidth;
                        }
                    } else {
                        if (height > maxHeight) {
                            width = (width * maxHeight) / height;
                            height = maxHeight;
                        }
                    }

                    canvas.width = width;
                    canvas.height = height;

                    // Draw and compress
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    canvas.toBlob(resolve, 'image/jpeg', quality);
                };

                img.src = URL.createObjectURL(file);
            });
        }

        // Update all profile picture displays throughout the app
        function updateAllProfileDisplays() {
            if (!currentUser) return;

            // Update header profile pic
            updateProfilePicture(userProfilePic, currentUser, 'profile-pic');

            // Update profile modal avatar
            updateProfilePicture(profileAvatar, currentUser, 'profile-avatar');

            // Update any visible posts by this user
            const postElements = document.querySelectorAll(`[data-user-id="${currentUser.uid}"]`);
            postElements.forEach(element => {
                if (element.classList.contains('post-profile-pic')) {
                    updateProfilePicture(element, currentUser, 'post-profile-pic');
                }
            });
            
            // Clear cache for current user so fresh data is fetched
            profilePictureCache.delete(currentUser.uid);
        }

        // Function to fetch and cache author profile pictures
        function fetchAuthorProfilePicture(authorId, authorUsername, profileElement) {
            // Set data attributes immediately for clicking
            profileElement.setAttribute('data-user-id', authorId);
            profileElement.setAttribute('data-username', authorUsername);
            
            // Check cache first
            if (profilePictureCache.has(authorId)) {
                const cachedUser = profilePictureCache.get(authorId);
                updateProfilePicture(profileElement, {...cachedUser, uid: authorId}, 'post-profile-pic');
                return;
            }

            // If it's the current user, use current user data
            if (currentUser && authorId === currentUser.uid) {
                updateProfilePicture(profileElement, currentUser, 'post-profile-pic');
                profilePictureCache.set(authorId, currentUser);
                return;
            }

            // Fetch from Firebase
            usersRef.child(authorId).once('value')
                .then(snapshot => {
                    const userData = snapshot.val();
                    const userForDisplay = {
                        uid: authorId,
                        username: authorUsername,
                        profilePicture: userData ? userData.profilePicture : null
                    };
                    
                    // Cache the result
                    profilePictureCache.set(authorId, userForDisplay);
                    
                    // Update the profile picture
                    updateProfilePicture(profileElement, userForDisplay, 'post-profile-pic');
                })
                .catch(error => {
                    console.error('Error fetching author profile picture:', error);
                    // Fallback to initial
                    const fallbackUser = { 
                        uid: authorId, 
                        username: authorUsername, 
                        profilePicture: null 
                    };
                    updateProfilePicture(profileElement, fallbackUser, 'post-profile-pic');
                });
        }

        // Full Screen Image Functions
        function showFullscreenImage(imageSrc, imageAlt = '') {
            if (!imageSrc || imageSrc.trim() === '') {
                console.warn('No image source provided for fullscreen view');
                return;
            }

            console.log('ðŸ“· Opening fullscreen image:', imageSrc.substring(0, 50) + '...');
            
            // Close other modals that might be open
            if (!profileModal.classList.contains('hidden')) {
                closeProfile();
            }
            if (!photoPreviewModal.classList.contains('hidden')) {
                cancelPhotoUpload();
            }
            if (!leaderboardModal.classList.contains('hidden')) {
                closeLeaderboard();
            }
            
            // Show the modal first
            fullscreenImageModal.classList.remove('hidden');
            
            // Show loading state
            fullscreenImage.style.display = 'none';
            const container = fullscreenImage.parentElement;
            
            // Create or show loading indicator
            let loadingDiv = container.querySelector('.fullscreen-loading');
            if (!loadingDiv) {
                loadingDiv = document.createElement('div');
                loadingDiv.className = 'fullscreen-loading';
                loadingDiv.textContent = 'Loading image...';
                container.appendChild(loadingDiv);
            }
            loadingDiv.style.display = 'block';
            
            // Load the image
            const img = new Image();
            img.onload = function() {
                // Hide loading and show image
                loadingDiv.style.display = 'none';
                fullscreenImage.src = imageSrc;
                fullscreenImage.alt = imageAlt;
                fullscreenImage.style.display = 'block';
            };
            
            img.onerror = function() {
                // Hide loading and show error
                loadingDiv.textContent = 'Error loading image';
                setTimeout(() => {
                    hideFullscreenImage();
                }, 2000);
            };
            
            img.src = imageSrc;
            
            // Prevent body scrolling when modal is open
            document.body.style.overflow = 'hidden';
        }

        function hideFullscreenImage() {
            console.log('ðŸ“· Closing fullscreen image');
            
            // Hide the modal
            fullscreenImageModal.classList.add('hidden');
            
            // Hide loading indicator if present
            const loadingDiv = fullscreenImageModal.querySelector('.fullscreen-loading');
            if (loadingDiv) {
                loadingDiv.style.display = 'none';
            }
            
            // Clear and hide the image completely
            fullscreenImage.style.display = 'none';
            fullscreenImage.removeAttribute('src');
            fullscreenImage.alt = '';
            
            // Restore body scrolling if no other modals are open
            if (profileModal.classList.contains('hidden') && photoPreviewModal.classList.contains('hidden') && leaderboardModal.classList.contains('hidden')) {
                document.body.style.overflow = '';
            }
        }

        // Profile event listeners
        closeProfileBtn.addEventListener('click', closeProfile);
        userProfilePic.addEventListener('click', () => {
            if (currentUser) {
                showProfile(currentUser.uid, currentUser.username);
            }
        });

        // Leaderboard event listeners
        leaderboardLink.addEventListener('click', showLeaderboard);
        closeLeaderboardBtn.addEventListener('click', closeLeaderboard);

        // NEW: Toggle event listener
        hideDislikedToggle.addEventListener('click', toggleHideDislikedPosts);

        // Photo upload event listeners
        changePhotoBtn.addEventListener('click', () => {
            photoUploadInput.click();
        });

        photoUploadInput.addEventListener('change', handlePhotoSelect);
        savePhotoBtn.addEventListener('click', saveProfilePhoto);
        cancelPhotoBtn.addEventListener('click', cancelPhotoUpload);

        // Full Screen Image Event Listeners
        fullscreenCloseBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent triggering the modal click handler
            hideFullscreenImage();
        });
        
        // Close fullscreen when clicking anywhere on the modal (background, container, or image)
        fullscreenImageModal.addEventListener('click', (e) => {
            hideFullscreenImage();
        });
        
        // Close fullscreen when clicking on the image itself (redundant but explicit)
        fullscreenImage.addEventListener('click', (e) => {
            hideFullscreenImage();
        });
        
        // Close fullscreen with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !fullscreenImageModal.classList.contains('hidden')) {
                hideFullscreenImage();
            }
        });

        // Close modals when clicking outside
        profileModal.addEventListener('click', (e) => {
            if (e.target === profileModal) {
                closeProfile();
            }
        });

        leaderboardModal.addEventListener('click', (e) => {
            if (e.target === leaderboardModal) {
                closeLeaderboard();
            }
        });

        photoPreviewModal.addEventListener('click', (e) => {
            if (e.target === photoPreviewModal) {
                cancelPhotoUpload();
            }
        });
        
        // Auth Event Listeners
        document.getElementById('login-btn').addEventListener('click', login);
        document.getElementById('signup-btn').addEventListener('click', signup);
        showSignupLink.addEventListener('click', (e) => {
            e.preventDefault();
            loginForm.classList.add('hidden');
            signupForm.classList.remove('hidden');
        });
        
        showLoginLink.addEventListener('click', (e) => {
            e.preventDefault();
            signupForm.classList.add('hidden');
            loginForm.classList.remove('hidden');
        });
        
        // Logout button is now in the profile modal, so we use event delegation
        document.addEventListener('click', function(e) {
            if (e.target && e.target.id === 'logout-btn') {
                logout();
            }
        });

        // Logo click to reload page
        if (logoElement) {
            logoElement.addEventListener('click', function() {
                location.reload();
            });
        }
        
        // Format seconds to MM:SS
        function formatDuration(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }
        
        // Helper function to format time
        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            
            let interval = Math.floor(seconds / 31536000);
            if (interval >= 1) {
                return interval === 1 ? '1 year ago' : `${interval} years ago`;
            }
            
            interval = Math.floor(seconds / 2592000);
            if (interval >= 1) {
                return interval === 1 ? '1 month ago' : `${interval} months ago`;
            }
            
            interval = Math.floor(seconds / 86400);
            if (interval >= 1) {
                return interval === 1 ? '1 day ago' : `${interval} days ago`;
            }
            
            interval = Math.floor(seconds / 3600);
            if (interval >= 1) {
                return interval === 1 ? '1 hour ago' : `${interval} hours ago`;
            }
            
            interval = Math.floor(seconds / 60);
            if (interval >= 1) {
                return interval === 1 ? '1 minute ago' : `${interval} minutes ago`;
            }
            
            return seconds < 10 ? 'just now' : `${seconds} seconds ago`;
        }
        
        // Auth state change listener
        auth.onAuthStateChanged((user) => {
            try {
                console.log('ðŸ” Auth state changed:', user ? 'logged in' : 'logged out');
                
                if (user) {
                    // User is signed in
                    // Get user profile data from database
                    usersRef.child(user.uid).once('value', (snapshot) => {
                        try {
                            const userData = snapshot.val();
                            if (userData) {
                                currentUser = {
                                    uid: user.uid,
                                    email: user.email,
                                    username: userData.username || 'User',
                                    profilePicture: userData.profilePicture || null
                                };
                                
                                console.log('ðŸ‘¤ Current user set:', currentUser.username);
                                
                                // Load user's disliked posts and settings
                                Promise.all([
                                    loadUserDislikedPosts(currentUser.uid),
                                    loadHideDislikedSetting(currentUser.uid)
                                ]).then(([dislikedPosts, hideDislikedSetting]) => {
                                    userDislikedPosts = dislikedPosts;
                                    console.log(`ðŸ“‹ Loaded ${userDislikedPosts.size} disliked posts for user`);
                                    
                                    // Apply the hide disliked posts setting
                                    applyHideDislikedSetting(hideDislikedSetting);
                                    console.log(`âš™ï¸ Restored hide disliked posts setting: ${hideDislikedSetting}`);
                                });
                                
                                // Update UI - Only update profile picture, not username display
                                updateProfilePicture(userProfilePic, currentUser, 'profile-pic');
                                showAppInterface();
                                loadPosts();
                            } else {
                                console.error('User data not found in database');
                                logout();
                            }
                        } catch (error) {
                            console.error('Error processing user data:', error);
                            logout();
                        }
                    }).catch(error => {
                        console.error('Error fetching user data:', error);
                        logout();
                    });
                } else {
                    // User is signed out
                    currentUser = null;
                    
                    // Reset user-specific settings
                    userDislikedPosts = new Set();
                    hideDislikedPosts = false;
                    
                    // Reset toggle UI
                    if (hideDislikedToggle) {
                        hideDislikedToggle.classList.remove('active');
                    }
                    
                    showAuthForms();
                }
                hideLoading();
            } catch (error) {
                console.error('Error in auth state change handler:', error);
                hideLoading();
            }
        });
        
        // Login Function
        function login() {
            const username = document.getElementById('login-username').value.trim();
            const password = document.getElementById('login-password').value;
            
            if (!username || !password) {
                alert('Please enter both username and password');
                return;
            }
            
            showLoading();
            
            // First look up the email associated with this username
            usersRef.orderByChild('username').equalTo(username).once('value')
                .then((snapshot) => {
                    if (!snapshot.exists()) {
                        hideLoading();
                        alert('Username not found');
                        return;
                    }
                    
                    // Get the user data which contains the email
                    let userData = null;
                    let userKey = null;
                    
                    snapshot.forEach((childSnapshot) => {
                        userData = childSnapshot.val();
                        userKey = childSnapshot.key;
                        return true; // Break the forEach loop after the first result
                    });
                    
                    if (!userData || !userData.email) {
                        hideLoading();
                        alert('Account information is incomplete');
                        return;
                    }
                    
                    // Now login with the email and password
                    auth.signInWithEmailAndPassword(userData.email, password)
                        .catch((error) => {
                            hideLoading();
                            alert(`Login failed: ${error.message}`);
                        });
                })
                .catch((error) => {
                    hideLoading();
                    alert(`Error looking up username: ${error.message}`);
                });
        }
        
        // Add input validation for the post form
        function setupInputValidation() {
            const postTextarea = document.getElementById('post-text');
            const maxLength = 2000;
            
            // Validate on input without showing counter
            postTextarea.addEventListener('input', function(e) {
                const currentLength = e.target.value.length;
                
                if (currentLength > maxLength) {
                    e.target.value = e.target.value.substring(0, maxLength);
                    alert(`Post text cannot exceed ${maxLength} characters`);
                }
            });
        }
        
        // Enhanced app interface setup
        function showAppInterface() {
            authForms.classList.add('hidden');
            appInterface.classList.remove('hidden');
            
            // Setup input validation when app interface is shown
            setupInputValidation();
        }
        
        // Signup Function
        function signup() {
            const username = document.getElementById('signup-username').value.trim();
            const email = document.getElementById('signup-email').value.trim();
            const password = document.getElementById('signup-password').value;
            const confirmPassword = document.getElementById('signup-confirm').value;
            
            if (!username || !email || !password || !confirmPassword) {
                alert('Please fill all fields');
                return;
            }
            
            // Validate username length (matches Firebase rule)
            if (username.length > 30) {
                alert('Username must be 30 characters or less');
                return;
            }
            
            // Basic email validation (Firebase rules have more strict validation)
            if (!email.includes('@') || !email.includes('.')) {
                alert('Please enter a valid email address');
                return;
            }
            
            // Validate password strength
            try {
                validatePassword(password);
            } catch (error) {
                alert(error.message);
                return;
            }
            
            if (password !== confirmPassword) {
                alert('Passwords do not match');
                return;
            }
            
            showLoading();
            
            // Check if username is already taken
            usersRef.orderByChild('username').equalTo(username).once('value', (snapshot) => {
                if (snapshot.exists()) {
                    hideLoading();
                    alert('Username already exists');
                    return;
                }
                
                // Create user with email and password
                auth.createUserWithEmailAndPassword(email, password)
                    .then((userCredential) => {
                        // Save additional user data (matches Firebase rule requirements)
                        usersRef.child(userCredential.user.uid).set({
                            username: username,  // Required by security rules
                            email: email,        // Required by security rules
                            profilePicture: null, // Initialize profile picture as null
                            createdAt: firebase.database.ServerValue.TIMESTAMP
                        });
                    })
                    .catch((error) => {
                        hideLoading();
                        handleFirebaseError(error);
                    });
            }).catch((error) => {
                hideLoading();
                handleFirebaseError(error);
            });
        }
        
        // Logout Function
        function logout() {
            // Close profile modal if it's open
            if (!profileModal.classList.contains('hidden')) {
                closeProfile();
            }
            
            // Close leaderboard modal if it's open
            if (!leaderboardModal.classList.contains('hidden')) {
                closeLeaderboard();
            }
            
            showLoading();
            auth.signOut()
                .catch((error) => {
                    console.error('Error signing out:', error);
                })
                .finally(() => {
                    hideLoading();
                });
        }
        
        // Post Creation Event Listeners
        imageInput.addEventListener('change', handleImageSelect);
        videoInput.addEventListener('change', handleVideoSelect);
        removeImageBtn.addEventListener('click', removeImage);
        removeVideoBtn.addEventListener('click', removeVideo);
        submitPostBtn.addEventListener('click', function(e) {
            e.preventDefault();
            createPost();
        });
        
        // Handle Image Selection
        function handleImageSelect(e) {
            const file = e.target.files[0];
            if (file) {
                // Validate file is an image
                if (!file.type.startsWith('image/')) {
                    alert('Please select an image file');
                    return;
                }
                
                // Clear any existing video if one was selected
                if (activeMediaType === 'video') {
                    removeVideo();
                }
                
                // Store file for later use (similar to video handling)
                window.selectedImageFile = file;
                
                const reader = new FileReader();
                
                reader.onload = function(event) {
                    previewImg.src = event.target.result;
                    imagePreview.style.display = 'block';
                    activeMediaType = 'image';
                };
                
                reader.onerror = function() {
                    alert('Error reading the image file');
                    console.error('FileReader error', reader.error);
                };
                
                reader.readAsDataURL(file);
            }
        }
        
        // Handle Video Selection
        function handleVideoSelect(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            console.log('Selected video file:', file.name, 'Type:', file.type, 'Size:', file.size);
            
            // Validate file is a video
            if (!file.type.startsWith('video/')) {
                alert('Please select a video file');
                return;
            }
            
            // Clear any existing image if one was selected
            if (activeMediaType === 'image') {
                removeImage();
            }
            
            // Store file for later use
            window.selectedVideoFile = file;
            
            // Create a blob URL for preview only
            const videoURL = URL.createObjectURL(file);
            previewVideo.src = videoURL;
            
            // Listen for metadata to check duration
            previewVideo.onloadedmetadata = function() {
                console.log('Video metadata loaded successfully');
                
                // Check if video is under 2 minutes (120 seconds)
                if (previewVideo.duration > 120) {
                    alert('Video must be under 2 minutes long. Please select a shorter video.');
                    removeVideo();
                    return;
                }
                
                // Display the duration
                videoDuration.textContent = formatDuration(previewVideo.duration);
                
                // Show the video preview
                videoPreview.style.display = 'block';
                activeMediaType = 'video';
                
                console.log('Video loaded successfully for preview');
            };
            
            // Handle video loading errors with detailed information
            previewVideo.onerror = function(e) {
                console.error('Video preview error:', e);
                alert('This video format might not be supported by your browser for preview. It may still upload successfully.');
                
                // Even if preview fails, we'll still allow upload since Firebase Storage handles conversion
                videoPreview.style.display = 'block';
                activeMediaType = 'video';
                videoDuration.textContent = 'Unknown';
            };
        }
        
        // Remove Selected Image
        function removeImage() {
            imageInput.value = '';
            if (previewImg.src) {
                URL.revokeObjectURL(previewImg.src);
                previewImg.src = '';
            }
            imagePreview.style.display = 'none';
            activeMediaType = null;
            // Clear any stored references
            window.selectedImageFile = null;
        }
        
        // Remove Selected Video
        function removeVideo() {
            videoInput.value = '';
            if (previewVideo.src) {
                previewVideo.pause();
                previewVideo.removeAttribute('src'); // Properly remove the source
                previewVideo.load(); // Reset the video element
                
                // If we used a blob URL, revoke it to prevent memory leaks
                if (previewVideo.src && previewVideo.src.startsWith('blob:')) {
                    URL.revokeObjectURL(previewVideo.src);
                }
                
                // Clear any stored references
                window.selectedVideoFile = null;
            }
            videoPreview.style.display = 'none';
            videoDuration.textContent = '00:00';
            activeMediaType = null;
        }
        
        // Create New Post
        function createPost() {
            if (!currentUser) {
                alert('You must be logged in to create a post');
                return;
            }
            
            const text = postTextarea.value.trim();
            
            // Check for YouTube URLs in the text
            const { cleanText, youtubeId, youtubeUrl } = extractYouTubeFromText(text);
            
            // Check media type
            let hasImage = activeMediaType === 'image' && window.selectedImageFile;
            let hasVideo = activeMediaType === 'video' && window.selectedVideoFile;
            
            if (!cleanText && !hasImage && !hasVideo && !youtubeId) {
                alert('Please add some text, an image, a video, or a YouTube URL to your post');
                return;
            }
            
            showLoading();
            
            // For image posts - upload to Firebase Storage
            if (hasImage) {
                try {
                    console.log('Starting image upload...');
                    console.log('File size:', window.selectedImageFile.size, 'bytes');
                    console.log('File type:', window.selectedImageFile.type);
                    console.log('User ID:', currentUser.uid);
                    
                    // Create a unique filename for the image
                    const imageFileName = 'images/' + currentUser.uid + '/' + Date.now() + '_' + window.selectedImageFile.name;
                    console.log('Upload path:', imageFileName);
                    
                    // Upload image to Firebase Storage
                    const imageRef = storageRef.child(imageFileName);
                    const uploadTask = imageRef.put(window.selectedImageFile);
                    
                    // Monitor upload progress
                    uploadTask.on('state_changed', 
                        // Progress function
                        (snapshot) => {
                            const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                            console.log('Upload progress: ' + progress.toFixed(1) + '%');
                        },
                        // Error function
                        (error) => {
                            console.error('Upload error details:', error);
                            console.error('Error code:', error.code);
                            console.error('Error message:', error.message);
                            alert('Error uploading image: ' + error.message);
                            hideLoading();
                        },
                        // Complete function
                        () => {
                            // Get the download URL
                            uploadTask.snapshot.ref.getDownloadURL().then((downloadURL) => {
                                console.log('Image uploaded successfully. URL:', downloadURL);
                                
                                // Now create post with the image URL and YouTube data
                                createFirebasePost(cleanText, downloadURL, null, null, null, youtubeId);
                            }).catch(urlError => {
                                console.error('Error getting download URL:', urlError);
                                alert('Error completing image upload. Please try again.');
                                hideLoading();
                            });
                        }
                    );
                } catch (error) {
                    console.error('Error uploading image:', error);
                    alert('Error processing image. Please try again with a different image.');
                    hideLoading();
                }
                return;
            }
            
            // For video posts
            if (hasVideo) {
                try {
                    console.log('Starting video upload...');
                    console.log('File size:', window.selectedVideoFile.size, 'bytes');
                    console.log('File type:', window.selectedVideoFile.type);
                    console.log('User ID:', currentUser.uid);
                    
                    // Create a unique filename for the video
                    const videoFileName = 'videos/' + currentUser.uid + '/' + Date.now() + '_' + window.selectedVideoFile.name;
                    console.log('Upload path:', videoFileName);
                    
                    // Get thumbnail
                    let thumbnailData = null;
                    try {
                        const canvas = document.createElement('canvas');
                        canvas.width = 320;
                        canvas.height = 180;
                        const ctx = canvas.getContext('2d');
                        
                        // Only try to draw if the video is ready
                        if (previewVideo.readyState >= 2) {
                            ctx.drawImage(previewVideo, 0, 0, canvas.width, canvas.height);
                            thumbnailData = canvas.toDataURL('image/jpeg', 0.8);
                        }
                    } catch (thumbErr) {
                        console.warn('Could not create thumbnail:', thumbErr);
                    }
                    
                    // Upload video to Firebase Storage
                    const videoRef = storageRef.child(videoFileName);
                    const uploadTask = videoRef.put(window.selectedVideoFile);
                    
                    // Monitor upload progress
                    uploadTask.on('state_changed', 
                        // Progress function
                        (snapshot) => {
                            const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                            console.log('Upload progress: ' + progress.toFixed(1) + '%');
                        },
                        // Error function
                        (error) => {
                            console.error('Upload error details:', error);
                            console.error('Error code:', error.code);
                            console.error('Error message:', error.message);
                            alert('Error uploading video: ' + error.message);
                            hideLoading();
                        },
                        // Complete function
                        () => {
                            // Get the download URL
                            uploadTask.snapshot.ref.getDownloadURL().then((downloadURL) => {
                                console.log('Video uploaded successfully. URL:', downloadURL);
                                
                                // Now create post with the video URL and YouTube data
                                const videoDuration = previewVideo.duration || 0;
                                createFirebasePost(cleanText, null, downloadURL, thumbnailData, videoDuration, youtubeId);
                            }).catch(urlError => {
                                console.error('Error getting download URL:', urlError);
                                alert('Error completing video upload. Please try again.');
                                hideLoading();
                            });
                        }
                    );
                } catch (error) {
                    console.error('Error uploading video:', error);
                    alert('Error processing video. Please try again with a different video.');
                    hideLoading();
                }
                return;
            }
            
            // Just text post (possibly with YouTube)
            createFirebasePost(cleanText, null, null, null, null, youtubeId);
        }
        
        // Create post in Firebase
        function createFirebasePost(text, imageURL, videoURL, videoThumbnail, videoDuration, youtubeId) {
            // Client-side validation before sending to Firebase
            if (!currentUser) {
                alert('You must be logged in to create a post');
                return;
            }
            
            // Validate text length (matches Firebase rule)
            if (text && text.length > 2000) {
                alert('Post text must be 2000 characters or less');
                return;
            }
            
            const newPostRef = postsRef.push();
            
            const newPost = {
                id: newPostRef.key,
                authorId: currentUser.uid,  // Required by security rules
                author: currentUser.username,  // Required by security rules
                authorProfilePicture: currentUser.profilePicture || null, // Include profile picture
                text: text || '',
                image: imageURL, // Now stores Firebase Storage URL instead of data URL
                videoURL: videoURL, // Firebase Storage URL for videos
                videoThumbnail: videoThumbnail,
                videoDuration: videoDuration,
                youtubeId: youtubeId || null, // YouTube video ID for embedded videos
                timestamp: firebase.database.ServerValue.TIMESTAMP,  // Required by security rules
                likes: 0,
                dislikes: 0
            };
            
            newPostRef.set(newPost)
                .then(() => {
                    // Reset form
                    postTextarea.value = '';
                    removeImage();
                    removeVideo();
                    
                    // Create a client-side copy of the post with current timestamp
                    const clientPost = {...newPost};
                    clientPost.timestamp = Date.now(); // Use current time since Firebase.ServerValue.TIMESTAMP can't be used client-side
                    
                    // Add to master posts array and sort
                    allPosts.unshift(clientPost);
                    sortAllPosts();
                    
                    // If this is the user's own post, show it immediately
                    if (newPost.authorId === currentUser.uid) {
                        currentPost = clientPost;
                        displayCurrentPost();
                    } else {
                        // Refresh queue to include new post
                        refreshViewingQueue();
                    }
                    
                    hideLoading();
                })
                .catch((error) => {
                    hideLoading();
                    handleFirebaseError(error);
                });
        }
        
        // NEW: Sort all posts by score (likes - dislikes)
        function sortAllPosts() {
            allPosts.sort((a, b) => {
                const scoreA = (a.likes || 0) - (a.dislikes || 0);
                const scoreB = (b.likes || 0) - (b.dislikes || 0);
                return scoreB - scoreA; // Highest score first
            });
            
            console.log('ðŸ“Š Posts sorted by score:', allPosts.map(p => ({
                author: p.author,
                score: (p.likes || 0) - (p.dislikes || 0),
                id: p.id.substring(0, 8)
            })));
        }
        
        // NEW: Remove duplicates from posts array
        function removeDuplicates(posts) {
            const seen = new Set();
            return posts.filter(post => {
                if (seen.has(post.id)) {
                    console.log('ðŸ” Removing duplicate post:', post.author, post.id.substring(0, 8));
                    return false;
                }
                seen.add(post.id);
                return true;
            });
        }
        
        // SIMPLIFIED: Refresh the viewing queue with top-ranked posts
        function refreshViewingQueue() {
            console.log(`ðŸ”„ Refreshing viewing queue (v${queueVersion++})...`);
            
            if (allPosts.length === 0) {
                console.log('âŒ No posts to add to queue');
                viewingQueue = [];
                return;
            }
            
            // If we've gone through all posts, start over
            if (currentCycleIndex >= allPosts.length) {
                currentCycleIndex = 0;
                recentlyDisliked.clear();
                console.log('ðŸ” Starting new cycle, cleared recently disliked');
            }
            
            // Filter posts based on user preferences
            let availablePosts = allPosts;
            
            // NEW: Filter out posts based on user's CURRENT final vote (not voting history)
            if (hideDislikedPosts && currentUser) {
                availablePosts = allPosts.filter(post => {
                    const isCurrentlyDisliked = userDislikedPosts.has(post.id);
                    if (isCurrentlyDisliked) {
                        console.log(`ðŸš« Hiding post with final dislike vote: ${post.author} (${post.id.substring(0, 8)})`);
                    }
                    return !isCurrentlyDisliked; // Only hide posts where user's FINAL vote is dislike
                });
                
                console.log(`ðŸ” Hide disliked filter: ${allPosts.length} â†’ ${availablePosts.length} posts (${userDislikedPosts.size} currently disliked)`);
            }
            
            if (availablePosts.length === 0) {
                console.log('âŒ No posts available after filtering');
                viewingQueue = [];
                postsFeed.innerHTML = '<div class="post-card"><div class="post-content"><p>No posts to show. Try disabling the dislike filter or create some posts!</p></div></div>';
                return;
            }
            
            // Simple approach: just get the next batch of posts
            const batchSize = Math.min(20, availablePosts.length);
            viewingQueue = [];
            
            // First, try to get posts that aren't recently disliked
            for (let i = 0; i < availablePosts.length && viewingQueue.length < batchSize; i++) {
                const postIndex = (currentCycleIndex + i) % availablePosts.length;
                const post = availablePosts[postIndex];
                
                if (!recentlyDisliked.has(post.id)) {
                    viewingQueue.push(post);
                }
            }
            
            // If we don't have enough posts (because too many are recently disliked), 
            // just add posts regardless of dislike status
            if (viewingQueue.length < Math.min(5, availablePosts.length)) {
                console.log('âš ï¸ Not enough posts after filtering, adding more regardless of recent dislike status');
                viewingQueue = [];
                
                for (let i = 0; i < batchSize && i < availablePosts.length; i++) {
                    const postIndex = (currentCycleIndex + i) % availablePosts.length;
                    viewingQueue.push(availablePosts[postIndex]);
                }
            }
            
            console.log(`ðŸ“‹ Queue refreshed: ${viewingQueue.length} posts added (batch size: ${batchSize}, cycle index: ${currentCycleIndex})`);
            
            // Show which posts are in the queue
            console.log('ðŸ“‹ Queue contents:', viewingQueue.slice(0, 3).map(p => `${p.author}(${p.id.substring(0, 6)})`));
        }
        
        // SIMPLIFIED: Show next post from queue
        function showNextPost() {
            // If queue is empty, refresh it
            if (viewingQueue.length === 0) {
                refreshViewingQueue();
            }
            
            // If still no posts after refresh, show message
            if (viewingQueue.length === 0) {
                postsFeed.innerHTML = '<div class="post-card"><div class="post-content"><p>No posts available. Be the first to share something!</p></div></div>';
                currentPost = null;
                return;
            }
            
            // Get next post from queue
            currentPost = viewingQueue.shift();
            
            // Only increment cycle index when queue gets rebuilt
            
            const score = (currentPost.likes || 0) - (currentPost.dislikes || 0);
            console.log(`ðŸ‘€ Showing post: ${currentPost.author} (score: ${score}, queue: ${viewingQueue.length} remaining, cycle: ${currentCycleIndex}/${allPosts.length})`);
            
            displayCurrentPost();
        }
        
        // NEW: Display the current post
        function displayCurrentPost() {
            if (!currentPost) {
                showNextPost();
                return;
            }
            
            // Make sure feed is visible
            postsFeed.style.display = 'flex';
            
            // Clear the feed and add the post
            postsFeed.innerHTML = '';
            const postCard = createPostElement(currentPost);
            postsFeed.appendChild(postCard);
        }
        
        // SIMPLIFIED: Load Posts with queue-based approach
        function loadPosts() {
            console.log('ðŸš€ Starting loadPosts function');
            showLoading();
            
            // Clear current state and ensure all variables are properly initialized
            allPosts = [];
            viewingQueue = [];
            currentPost = null;
            currentCycleIndex = 0;
            recentlyDisliked = new Set();
            queueVersion = 0;
            // Clear profile picture cache when loading posts
            profilePictureCache.clear();
            // NEW: Clear user disliked posts when loading posts
            userDislikedPosts = new Set();
            
            console.log('âœ… All variables cleared and initialized');
            
            // Load user's disliked posts if logged in
            if (currentUser) {
                loadUserDislikedPosts(currentUser.uid).then(dislikedPosts => {
                    userDislikedPosts = dislikedPosts;
                    console.log(`ðŸ“‹ Loaded ${userDislikedPosts.size} disliked posts for current user`);
                });
            }
            
            // Get posts from Firebase
            postsRef.orderByChild('timestamp').limitToLast(50).once('value')
                .then((snapshot) => {
                    console.log('ðŸ“¦ Firebase data received');
                    const postsData = [];
                    snapshot.forEach((childSnapshot) => {
                        postsData.push(childSnapshot.val());
                    });
                    
                    // Remove duplicates and reverse to get newest first
                    allPosts = removeDuplicates(postsData.reverse());
                    console.log(`ðŸ“‹ Processed ${allPosts.length} posts`);
                    
                    // Sort by score
                    sortAllPosts();
                    
                    if (allPosts.length > 0) {
                        refreshViewingQueue();
                        showNextPost();
                    } else {
                        postsFeed.innerHTML = '<div class="post-card"><div class="post-content"><p>No posts yet. Be the first to share something!</p></div></div>';
                    }
                    
                    hideLoading();
                    
                    // Set up real-time listeners for posts
                    setupPostListeners();
                })
                .catch((error) => {
                    console.error('Error loading posts:', error);
                    postsFeed.innerHTML = '<div class="post-card"><div class="post-content"><p>Error loading posts. Please try again later.</p></div></div>';
                    hideLoading();
                });
        }
        
        // SIMPLIFIED: Setup real-time listeners with queue management
        function setupPostListeners() {
            // Listen for new posts
            postsRef.limitToLast(1).on('child_added', (snapshot) => {
                const newPost = snapshot.val();
                
                // Check if this post is already in our array
                const existingIndex = allPosts.findIndex(p => p.id === newPost.id);
                
                if (existingIndex === -1) {
                    console.log('âž• New post added:', newPost.author);
                    
                    // Add to master array and re-sort
                    allPosts.unshift(newPost);
                    allPosts = removeDuplicates(allPosts);
                    sortAllPosts();
                    
                    // If it's from current user, show immediately by updating queue
                    if (newPost.authorId === currentUser.uid) {
                        currentPost = newPost;
                        displayCurrentPost();
                    } else {
                        // Refresh queue to include new post
                        refreshViewingQueue();
                    }
                }
            });
            
            // Listen for post updates (likes, dislikes, comments)
            postsRef.on('child_changed', (snapshot) => {
                const updatedPost = snapshot.val();
                
                // Find and update the post in our master array
                const postIndex = allPosts.findIndex(p => p.id === updatedPost.id);
                
                if (postIndex !== -1) {
                    const oldScore = (allPosts[postIndex].likes || 0) - (allPosts[postIndex].dislikes || 0);
                    const newScore = (updatedPost.likes || 0) - (updatedPost.dislikes || 0);
                    
                    console.log(`ðŸ“ˆ Post updated: ${updatedPost.author} (${oldScore} â†’ ${newScore})`);
                    
                    // Update the post data
                    allPosts[postIndex] = updatedPost;
                    
                    // Re-sort if score changed
                    if (oldScore !== newScore) {
                        sortAllPosts();
                        
                        // Don't refresh queue immediately to avoid disrupting user experience
                        // Queue will refresh naturally when it empties
                    }
                    
                    // Update display if this is the current post
                    if (currentPost && currentPost.id === updatedPost.id) {
                        currentPost = updatedPost;
                        displayCurrentPost();
                    }
                }
            });
        }
        
        // UPDATED: goToNextPost using queue system (fixed cycle management)
        function goToNextPost() {
            // Update cycle index when queue is about to empty (advance through the array)
            if (viewingQueue.length <= 1) {
                // When queue is nearly empty, advance our position in the main array
                currentCycleIndex = Math.min(currentCycleIndex + 10, allPosts.length);
                console.log(`ðŸ”„ Queue nearly empty, advancing cycle index to ${currentCycleIndex}`);
            }
            
            showNextPost();
            return true;
        }
        
        // Render Comments Function
        function renderComments(post) {
            if (!post.comments) {
                return '';
            }
            
            const commentsArray = [];
            for (const commentId in post.comments) {
                commentsArray.push({
                    id: commentId,
                    ...post.comments[commentId]
                });
            }
            
            if (commentsArray.length === 0) {
                return '';
            }
            
            // Sort comments by timestamp (newest last)
            commentsArray.sort((a, b) => a.timestamp - b.timestamp);
            
            return commentsArray.map(comment => {
                const commentDate = new Date(comment.timestamp);
                const timeAgo = getTimeAgo(commentDate);
                
                let repliesHtml = '';
                
                // Process replies if they exist
                if (comment.replies) {
                    const repliesArray = [];
                    for (const replyId in comment.replies) {
                        repliesArray.push({
                            id: replyId,
                            ...comment.replies[replyId]
                        });
                    }
                    
                    if (repliesArray.length > 0) {
                        // Sort replies by timestamp
                        repliesArray.sort((a, b) => a.timestamp - b.timestamp);
                        
                        repliesHtml = `
                            <div class="thread-toggle" data-comment-id="${comment.id}">
                                <span class="thread-toggle-icon">â–¶</span>
                                <span>Show ${repliesArray.length} ${repliesArray.length === 1 ? 'reply' : 'replies'}</span>
                            </div>
                            <div class="thread-replies" id="replies-${comment.id}">
                                ${repliesArray.map(reply => {
                                    const replyDate = new Date(reply.timestamp);
                                    const replyTimeAgo = getTimeAgo(replyDate);
                                    
                                    return `
                                        <div class="comment" data-reply-id="${reply.id}">
                                            <div class="comment-header">
                                                <span class="comment-author" data-user-id="${reply.authorId}" data-username="${reply.author}">${reply.author}</span>
                                                <span class="comment-time">${replyTimeAgo}</span>
                                            </div>
                                            <div class="comment-text">${linkifyText(reply.text)}</div>
                                        </div>
                                    `;
                                }).join('')}
                                <div class="reply-form">
                                    <input type="text" class="reply-input" placeholder="Add a reply...">
                                    <button class="add-reply-btn" data-post-id="${post.id}" data-comment-id="${comment.id}">Reply</button>
                                </div>
                            </div>
                        `;
                    } else {
                        repliesHtml = `
                            <div class="reply-form">
                                <input type="text" class="reply-input" placeholder="Add a reply...">
                                <button class="add-reply-btn" data-post-id="${post.id}" data-comment-id="${comment.id}">Reply</button>
                            </div>
                        `;
                    }
                } else {
                    repliesHtml = `
                        <div class="reply-form">
                            <input type="text" class="reply-input" placeholder="Add a reply...">
                            <button class="add-reply-btn" data-post-id="${post.id}" data-comment-id="${comment.id}">Reply</button>
                        </div>
                    `;
                }
                
                return `
                    <div class="comment" data-comment-id="${comment.id}">
                        <div class="comment-header">
                            <span class="comment-author" data-user-id="${comment.authorId}" data-username="${comment.author}">${comment.author}</span>
                            <span class="comment-time">${timeAgo}</span>
                        </div>
                        <div class="comment-text">${linkifyText(comment.text)}</div>
                        ${repliesHtml}
                    </div>
                `;
            }).join('');
        }
        
        // Create Post Element
        function createPostElement(post) {
            const postCard = document.createElement('div');
            postCard.className = 'post-card';
            postCard.dataset.id = post.id;
            
            // Format timestamp
            const postDate = new Date(post.timestamp);
            const timeAgo = getTimeAgo(postDate);
            
            // Determine what media content to show
            let mediaContent = '';
            if (post.youtubeId) {
                // YouTube embedded video
                mediaContent = `
                    <div class="youtube-embed-container" style="position: relative; width: 100%; height: 0; padding-bottom: 56.25%; /* 16:9 aspect ratio */">
                        <iframe 
                            src="https://www.youtube.com/embed/${post.youtubeId}?rel=0&modestbranding=1" 
                            frameborder="0" 
                            allowfullscreen
                            style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 8px;"
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                        ></iframe>
                    </div>
                `;
            } else if (post.videoURL) {
                // Regular uploaded video with autoplay
                mediaContent = `
                    <video class="post-video" src="${post.videoURL}" controls autoplay muted loop playsinline></video>
                `;
            } else if (post.image && post.image.trim() !== '') {
                // Image posts
                mediaContent = `<img class="post-image" src="${post.image}" alt="">`;
            }
            
            postCard.innerHTML = `
                <div class="post-header">
                    <div class="post-profile-pic" data-user-id="${post.authorId}" data-username="${post.author}"></div>
                    <div>
                        <div class="post-author" data-user-id="${post.authorId}" data-username="${post.author}">${post.author}</div>
                        <div class="post-time">${timeAgo}</div>
                    </div>
                </div>
                <div class="post-content">
                    <p>${linkifyText(post.text || '')}</p>
                    ${mediaContent}
                </div>
                <div class="comments-section" id="comments-${post.id}">
                    <div class="comment-form">
                        <input type="text" class="comment-input" placeholder="Add a comment...">
                        <button class="add-comment-btn" data-post-id="${post.id}">Post</button>
                    </div>
                    <div class="comments-container">
                        ${renderComments(post)}
                    </div>
                </div>
                <div class="swipe-overlay like-overlay"></div>
                <div class="swipe-overlay dislike-overlay"></div>
            `;
            
            // Update the profile picture after creating the element
            const profilePicElement = postCard.querySelector('.post-profile-pic');
            
            // Fetch and update profile picture for this author
            fetchAuthorProfilePicture(post.authorId, post.author, profilePicElement);
            
            // Add swipe functionality - but prevent it over YouTube iframes
            let startX = 0;
            let currentX = 0;
            let isSwiping = false;
            const swipeThreshold = 10; // Pixels to move before considering it a swipe
            let swipeProcessed = false; // Flag to prevent duplicate processing
            
            // Function to check if the target is a YouTube iframe or its container
            function isYouTubeElement(target) {
                return target.tagName === 'IFRAME' || 
                       target.closest('.youtube-embed-container') ||
                       target.classList.contains('youtube-embed-container');
            }
            
            // Touch event handling
            postCard.addEventListener('touchstart', function(e) {
                // Don't start swipe if touching YouTube embed
                if (isYouTubeElement(e.target)) {
                    return;
                }
                
                startX = e.touches[0].clientX;
                currentX = startX; 
                isSwiping = false;
                swipeProcessed = false;
                this.style.transition = 'none';
            });
            
            postCard.addEventListener('touchmove', function(e) {
                if (swipeProcessed) return;
                
                // Don't swipe if moving over YouTube embed
                if (isYouTubeElement(e.target)) {
                    return;
                }
                
                currentX = e.touches[0].clientX;
                const diffX = currentX - startX;
                
                // Check if user has moved enough to be considered a swipe
                if (!isSwiping && Math.abs(diffX) >= swipeThreshold) {
                    isSwiping = true;
                }
                
                // Only proceed with swipe behavior if we're in swipe mode
                if (isSwiping) {
                    // Limit the swipe distance
                    const limitedDiff = Math.max(Math.min(diffX, 150), -150);
                    
                    this.style.transform = `translateX(${limitedDiff}px)`;
                    
                    // Show overlay based on swipe direction
                    if (diffX > 0) {
                        this.querySelector('.like-overlay').style.opacity = limitedDiff / 150;
                        this.querySelector('.dislike-overlay').style.opacity = 0;
                    } else if (diffX < 0) {
                        this.querySelector('.dislike-overlay').style.opacity = Math.abs(limitedDiff) / 150;
                        this.querySelector('.like-overlay').style.opacity = 0;
                    }
                }
            });
            
            postCard.addEventListener('touchend', function(e) {
                if (swipeProcessed) return;
                
                const diffX = currentX - startX;
                this.style.transition = 'transform 0.3s ease';
                
                // Only process swipe if we were actually swiping
                if (isSwiping) {
                    // Handle significant swipe
                    if (Math.abs(diffX) > 80) {
                        swipeProcessed = true;
                        
                        // Animate the swipe out
                        const direction = diffX > 0 ? 1 : -1;
                        this.style.transform = `translateX(${direction * window.innerWidth}px)`;
                        
                        setTimeout(() => {
                            // Reset overlays
                            this.querySelector('.like-overlay').style.opacity = 0;
                            this.querySelector('.dislike-overlay').style.opacity = 0;
                            
                            // Process the like/dislike
                            if (diffX > 80) {
                                handlePostLike(post.id);
                            } else if (diffX < -80) {
                                handlePostDislike(post.id);
                            }
                            
                            // After like/dislike is processed, go to next post
                            goToNextPost();
                        }, 300); // Wait for animation to complete
                    } else {
                        // Reset if not a significant swipe
                        this.style.transform = 'translateX(0)';
                        
                        // Reset overlays
                        this.querySelector('.like-overlay').style.opacity = 0;
                        this.querySelector('.dislike-overlay').style.opacity = 0;
                    }
                } else {
                    // It was just a tap, not a swipe
                    this.style.transform = 'translateX(0)';
                }
            });
            
            // For desktop testing - mouse events (with same YouTube protection)
            postCard.addEventListener('mousedown', function(e) {
                // Don't start swipe if clicking on YouTube embed
                if (isYouTubeElement(e.target)) {
                    return;
                }
                
                startX = e.clientX;
                currentX = startX;
                isSwiping = false;
                swipeProcessed = false;
                this.style.transition = 'none';
                
                const handleMouseMove = (e) => {
                    if (swipeProcessed) return;
                    
                    currentX = e.clientX;
                    const diffX = currentX - startX;
                    
                    // Check if user has moved enough to be considered a swipe
                    if (!isSwiping && Math.abs(diffX) >= swipeThreshold) {
                        isSwiping = true;
                    }
                    
                    // Only proceed with swipe behavior if we're in swipe mode
                    if (isSwiping) {
                        // Limit the swipe distance
                        const limitedDiff = Math.max(Math.min(diffX, 150), -150);
                        
                        this.style.transform = `translateX(${limitedDiff}px)`;
                        
                        // Show overlay based on swipe direction
                        if (diffX > 0) {
                            this.querySelector('.like-overlay').style.opacity = limitedDiff / 150;
                            this.querySelector('.dislike-overlay').style.opacity = 0;
                        } else if (diffX < 0) {
                            this.querySelector('.dislike-overlay').style.opacity = Math.abs(limitedDiff) / 150;
                            this.querySelector('.like-overlay').style.opacity = 0;
                        }
                    }
                };
                
                const handleMouseUp = (e) => {
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                    
                    if (swipeProcessed) return;
                    
                    const diffX = currentX - startX;
                    this.style.transition = 'transform 0.3s ease';
                    
                    // Only process swipe if we were actually swiping
                    if (isSwiping) {
                        // Handle significant swipe
                        if (Math.abs(diffX) > 80) {
                            swipeProcessed = true;
                            
                            // Animate the swipe out
                            const direction = diffX > 0 ? 1 : -1;
                            this.style.transform = `translateX(${direction * window.innerWidth}px)`;
                            
                            setTimeout(() => {
                                // Reset overlays
                                this.querySelector('.like-overlay').style.opacity = 0;
                                this.querySelector('.dislike-overlay').style.opacity = 0;
                                
                                // Process the like/dislike
                                if (diffX > 80) {
                                    handlePostLike(post.id);
                                } else if (diffX < -80) {
                                    handlePostDislike(post.id);
                                }
                                
                                // After like/dislike is processed, go to next post
                                goToNextPost();
                            }, 300); // Wait for animation to complete
                        } else {
                            // Reset if not a significant swipe
                            this.style.transform = 'translateX(0)';
                            
                            // Reset overlays
                            this.querySelector('.like-overlay').style.opacity = 0;
                            this.querySelector('.dislike-overlay').style.opacity = 0;
                        }
                    } else {
                        // It was just a click, not a swipe
                        this.style.transform = 'translateX(0)';
                    }
                };
                
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            });
            
            return postCard;
        }
        
        // NEW: Show brief feedback message to user
        function showVoteFeedback(message, type = 'info') {
            // Remove any existing feedback
            const existingFeedback = document.querySelector('.vote-feedback');
            if (existingFeedback) {
                existingFeedback.remove();
            }
            
            // Create feedback element
            const feedback = document.createElement('div');
            feedback.className = 'vote-feedback';
            feedback.textContent = message;
            feedback.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background-color: ${type === 'warning' ? 'var(--secondary-color)' : 'var(--primary-color)'};
                color: white;
                padding: 0.8rem 1.5rem;
                border-radius: 8px;
                font-weight: 600;
                z-index: 2500;
                box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
                animation: fadeInOut 2s ease;
                pointer-events: none;
            `;
            
            // Add animation keyframes if not already added
            if (!document.querySelector('#vote-feedback-styles')) {
                const style = document.createElement('style');
                style.id = 'vote-feedback-styles';
                style.textContent = `
                    @keyframes fadeInOut {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(feedback);
            
            // Remove after animation
            setTimeout(() => {
                if (feedback.parentNode) {
                    feedback.remove();
                }
            }, 2000);
        }
        function handlePostLike(postId) {
            if (!currentUser) {
                alert('Please log in to like posts');
                return;
            }
            
            console.log('ðŸ‘ Processing like for post:', postId.substring(0, 8));
            
            // Check user's current vote status
            Promise.all([
                usersRef.child(`${currentUser.uid}/likedPosts/${postId}`).once('value'),
                usersRef.child(`${currentUser.uid}/dislikedPosts/${postId}`).once('value')
            ]).then(([likedSnapshot, dislikedSnapshot]) => {
                const hasLiked = likedSnapshot.exists();
                const hasDisliked = dislikedSnapshot.exists();
                
                if (hasLiked) {
                    console.log('âš ï¸ User already liked this post');
                    return; // User already liked this post, do nothing
                }
                
                const postRef = postsRef.child(postId);
                
                if (hasDisliked) {
                    // User is changing from dislike to like
                    console.log('ðŸ”„ Changing vote from dislike to like');
                    
                    // Use transactions to update both counters atomically
                    Promise.all([
                        postRef.child('likes').transaction((currentLikes) => (currentLikes || 0) + 1),
                        postRef.child('dislikes').transaction((currentDislikes) => Math.max((currentDislikes || 0) - 1, 0))
                    ]).then(() => {
                        // Update user's vote records - properly remove the dislike entry
                        const likeRef = usersRef.child(`${currentUser.uid}/likedPosts/${postId}`);
                        const dislikeRef = usersRef.child(`${currentUser.uid}/dislikedPosts/${postId}`);
                        
                        return Promise.all([
                            likeRef.set(true),
                            dislikeRef.remove() // Properly delete the dislike entry
                        ]);
                    }).then(() => {
                        // Update local cache and refresh to ensure accuracy
                        userDislikedPosts.delete(postId);
                        
                        // Refresh cache from Firebase to ensure accuracy
                        refreshUserDislikedPosts().then(() => {
                            // Refresh viewing queue if hide disliked is enabled
                            if (hideDislikedPosts) {
                                console.log('ðŸ”„ Refreshing queue after vote change to show previously hidden post');
                                refreshViewingQueue();
                            }
                        });
                        
                        console.log('âœ… Vote changed from dislike to like, dislike entry removed');
                    }).catch(handleFirebaseError);
                    
                } else {
                    // User is liking for the first time
                    console.log('âž• New like vote');
                    
                    postRef.child('likes').transaction((currentLikes) => {
                        return (currentLikes || 0) + 1;
                    }).then(() => {
                        // Track user's like
                        return usersRef.child(`${currentUser.uid}/likedPosts/${postId}`).set(true);
                    }).then(() => {
                        console.log('âœ… New like recorded');
                    }).catch(handleFirebaseError);
                }
            }).catch(handleFirebaseError);
        }
        
        // NEW: Enhanced Handle Post Dislike with single-vote system
        function handlePostDislike(postId) {
            if (!currentUser) {
                alert('Please log in to dislike posts');
                return;
            }
            
            console.log('ðŸ‘Ž Processing dislike for post:', postId.substring(0, 8));
            
            // Check user's current vote status
            Promise.all([
                usersRef.child(`${currentUser.uid}/likedPosts/${postId}`).once('value'),
                usersRef.child(`${currentUser.uid}/dislikedPosts/${postId}`).once('value')
            ]).then(([likedSnapshot, dislikedSnapshot]) => {
                const hasLiked = likedSnapshot.exists();
                const hasDisliked = dislikedSnapshot.exists();
                
                if (hasDisliked) {
                    console.log('âš ï¸ User already disliked this post');
                    return; // User already disliked this post, do nothing
                }
                
                const postRef = postsRef.child(postId);
                
                if (hasLiked) {
                    // User is changing from like to dislike
                    console.log('ðŸ”„ Changing vote from like to dislike');
                    
                    // Use transactions to update both counters atomically
                    Promise.all([
                        postRef.child('dislikes').transaction((currentDislikes) => (currentDislikes || 0) + 1),
                        postRef.child('likes').transaction((currentLikes) => Math.max((currentLikes || 0) - 1, 0))
                    ]).then(() => {
                        // Update user's vote records - properly remove the like entry
                        const dislikeRef = usersRef.child(`${currentUser.uid}/dislikedPosts/${postId}`);
                        const likeRef = usersRef.child(`${currentUser.uid}/likedPosts/${postId}`);
                        
                        return Promise.all([
                            dislikeRef.set(true),
                            likeRef.remove() // Properly delete the like entry
                        ]);
                    }).then(() => {
                        // Update local cache and refresh to ensure accuracy
                        userDislikedPosts.add(postId);
                        
                        // Refresh cache from Firebase to ensure accuracy
                        refreshUserDislikedPosts();
                        
                        console.log('âœ… Vote changed from like to dislike, like entry removed');
                    }).catch(handleFirebaseError);
                    
                } else {
                    // User is disliking for the first time
                    console.log('âž• New dislike vote');
                    
                    postRef.child('dislikes').transaction((currentDislikes) => {
                        return (currentDislikes || 0) + 1;
                    }).then(() => {
                        // Track user's dislike
                        return usersRef.child(`${currentUser.uid}/dislikedPosts/${postId}`).set(true);
                    }).then(() => {
                        // Update local cache
                        userDislikedPosts.add(postId);
                        
                        console.log('âœ… New dislike recorded');
                    }).catch(handleFirebaseError);
                }
            }).catch(handleFirebaseError);
            
            // Add this post to the recently disliked set for feed management
            recentlyDisliked.add(postId);
            
            // Limit recently disliked to prevent too many posts being filtered out
            if (recentlyDisliked.size > 5) {
                const dislikedArray = Array.from(recentlyDisliked);
                recentlyDisliked.delete(dislikedArray[0]);
            }
            
            console.log(`ðŸ“ Post added to recently disliked, count: ${recentlyDisliked.size}`);
        }
        
        // Event delegation for dynamic elements
        document.addEventListener('click', function(e) {
            // Profile post delete button clicked
            if (e.target.closest('.profile-post-delete-btn')) {
                e.stopPropagation(); // Prevent opening the post
                const button = e.target.closest('.profile-post-delete-btn');
                const postId = button.getAttribute('data-post-id');
                
                if (postId) {
                    deletePost(postId);
                }
                return;
            }

            // NEW: Profile post click handling - check for profile post clicks first
            if (e.target.closest('.profile-post-card[data-post-id]')) {
                const postCard = e.target.closest('.profile-post-card[data-post-id]');
                const postId = postCard.getAttribute('data-post-id');
                
                if (postId) {
                    console.log('ðŸŽ¯ Profile post clicked:', postId);
                    openPostInFeed(postId);
                    return; // Stop event propagation
                }
            }

            // NEW: Leaderboard post click handling
            if (e.target.closest('.leaderboard-post-card[data-post-id]')) {
                const postCard = e.target.closest('.leaderboard-post-card[data-post-id]');
                const postId = postCard.getAttribute('data-post-id');
                
                if (postId) {
                    console.log('ðŸ† Leaderboard post clicked:', postId);
                    openPostInFeed(postId);
                    return; // Stop event propagation
                }
            }

            // Full screen image handling
            if (e.target.classList.contains('post-image')) {
                e.stopPropagation(); // Prevent any swipe or other post interactions
                const imageSrc = e.target.src;
                const imageAlt = e.target.alt || 'Post image';
                showFullscreenImage(imageSrc, imageAlt);
                return;
            }

            // Profile click handling
            if (e.target.closest('[data-user-id]')) {
                const element = e.target.closest('[data-user-id]');
                const userId = element.getAttribute('data-user-id');
                let username = element.getAttribute('data-username');
                
                // Fallback to text content if no data-username attribute
                if (!username) {
                    username = element.textContent.trim();
                }
                
                if (userId && username) {
                    showProfile(userId, username);
                }
                return;
            }

            // Add comment button clicked
            if (e.target.closest('.add-comment-btn')) {
                const button = e.target.closest('.add-comment-btn');
                const postId = button.getAttribute('data-post-id');
                const form = button.closest('.comment-form');
                const input = form ? form.querySelector('input') : null;
                
                if (input && input.value.trim() && currentUser) {
                    addComment(postId, input.value.trim());
                    input.value = '';
                }
            }
            
            // Thread toggle clicked
            if (e.target.closest('.thread-toggle')) {
                const toggle = e.target.closest('.thread-toggle');
                const commentId = toggle.getAttribute('data-comment-id');
                const repliesContainer = document.getElementById(`replies-${commentId}`);
                
                if (repliesContainer) {
                    repliesContainer.classList.toggle('open');
                    const icon = toggle.querySelector('.thread-toggle-icon');
                    
                    if (icon) {
                        icon.classList.toggle('open');
                    }
                    
                    // Update toggle text
                    const text = toggle.querySelector('span:last-child');
                    if (text) {
                        const replyCount = repliesContainer.querySelectorAll('.comment[data-reply-id]').length;
                        
                        if (repliesContainer.classList.contains('open')) {
                            text.textContent = `Hide ${replyCount} ${replyCount === 1 ? 'reply' : 'replies'}`;
                        } else {
                            text.textContent = `Show ${replyCount} ${replyCount === 1 ? 'reply' : 'replies'}`;
                        }
                    }
                }
            }
            
            // Add reply button clicked
            if (e.target.closest('.add-reply-btn')) {
                const button = e.target.closest('.add-reply-btn');
                const postId = button.getAttribute('data-post-id');
                const commentId = button.getAttribute('data-comment-id');
                const form = button.closest('.reply-form');
                const input = form ? form.querySelector('input') : null;
                
                if (input && input.value.trim() && currentUser) {
                    addReply(postId, commentId, input.value.trim());
                    input.value = '';
                }
            }
        });
        
        // Add input validation for comment and reply inputs
        document.addEventListener('input', function(e) {
            if (e.target.classList.contains('comment-input') || e.target.classList.contains('reply-input')) {
                const maxLength = 500;
                const currentLength = e.target.value.length;
                
                if (currentLength > maxLength) {
                    e.target.value = e.target.value.substring(0, maxLength);
                    alert(`Comments must be ${maxLength} characters or less`);
                }
            }
        });
        
        // Add comment to Firebase
        function addComment(postId, commentText) {
            if (!currentUser || !commentText.trim()) return;
            
            // Validate comment length (matches Firebase rule)
            if (commentText.trim().length > 500) {
                alert('Comments must be 500 characters or less');
                return;
            }
            
            showLoading();
            
            // Create a new comment reference
            const commentRef = postsRef.child(`${postId}/comments`).push();
            
            const newComment = {
                author: currentUser.username,  // Required by security rules
                authorId: currentUser.uid,     // Required by security rules
                text: commentText.trim(),      // Required by security rules
                timestamp: firebase.database.ServerValue.TIMESTAMP  // Required by security rules
            };
            
            commentRef.set(newComment)
                .then(() => {
                    hideLoading();
                    
                    // Highlight the new comment after it's been added
                    setTimeout(() => {
                        const commentElement = document.querySelector(`.comment[data-comment-id="${commentRef.key}"]`);
                        if (commentElement) {
                            commentElement.classList.add('new-comment');
                            commentElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }, 300);
                })
                .catch((error) => {
                    hideLoading();
                    handleFirebaseError(error);
                });
        }
        
        // Add reply to Firebase
        function addReply(postId, commentId, replyText) {
            if (!currentUser || !replyText.trim()) return;
            
            // Validate reply length
            if (replyText.trim().length > 500) {
                alert('Replies must be 500 characters or less');
                return;
            }
            
            showLoading();
            
            // Create a new reply reference
            const replyRef = postsRef.child(`${postId}/comments/${commentId}/replies`).push();
            
            const newReply = {
                author: currentUser.username,  // Required by security rules
                authorId: currentUser.uid,     // Required by security rules
                text: replyText.trim(),        // Required by security rules
                timestamp: firebase.database.ServerValue.TIMESTAMP  // Required by security rules
            };
            
            replyRef.set(newReply)
                .then(() => {
                    hideLoading();
                    
                    // Make sure the replies container is open
                    const repliesContainer = document.getElementById(`replies-${commentId}`);
                    if (repliesContainer) {
                        repliesContainer.classList.add('open');
                        
                        // Update the toggle icon and text
                        const threadToggle = document.querySelector(`.thread-toggle[data-comment-id="${commentId}"]`);
                        if (threadToggle) {
                            const icon = threadToggle.querySelector('.thread-toggle-icon');
                            if (icon) icon.classList.add('open');
                            
                            const text = threadToggle.querySelector('span:last-child');
                            if (text) {
                                // Count replies after the new one has been added
                                postsRef.child(`${postId}/comments/${commentId}/replies`).once('value', (snapshot) => {
                                    const replyCount = snapshot.numChildren();
                                    text.textContent = `Hide ${replyCount} ${replyCount === 1 ? 'reply' : 'replies'}`;
                                });
                            }
                        }
                        
                        // Highlight the new reply after it's been added
                        setTimeout(() => {
                            const replyElements = repliesContainer.querySelectorAll('.comment[data-reply-id]');
                            if (replyElements.length > 0) {
                                const lastReply = replyElements[replyElements.length - 1];
                                lastReply.classList.add('new-comment');
                                lastReply.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        }, 300);
                    }
                })
                .catch((error) => {
                    hideLoading();
                    handleFirebaseError(error);
                });
        }
        
        // Delete Post Function
        function deletePost(postId) {
            if (!currentUser) {
                alert('You must be logged in to delete posts');
                return;
            }
            
            // Show confirmation dialog
            if (!confirm('Are you sure you want to delete this post? This action cannot be undone.')) {
                return;
            }
            
            showLoading();
            
            // First, get the post data to find any media files to delete
            postsRef.child(postId).once('value')
                .then((snapshot) => {
                    const postData = snapshot.val();
                    
                    if (!postData) {
                        hideLoading();
                        alert('Post not found');
                        return;
                    }
                    
                    // Check if user owns this post
                    if (postData.authorId !== currentUser.uid) {
                        hideLoading();
                        alert('You can only delete your own posts');
                        return;
                    }
                    
                    // Delete the post from Firebase Database
                    postsRef.child(postId).remove()
                        .then(() => {
                            console.log('âœ… Post deleted from database:', postId);
                            
                            // Delete associated media files from Storage
                            const deletePromises = [];
                            
                            // Delete image if it's stored in Firebase Storage
                            if (postData.image && postData.image.includes('firebase')) {
                                try {
                                    const imageRef = storage.refFromURL(postData.image);
                                    deletePromises.push(imageRef.delete());
                                    console.log('ðŸ—‘ï¸ Deleting image from storage');
                                } catch (error) {
                                    console.warn('Could not delete image from storage:', error);
                                }
                            }
                            
                            // Delete video if it exists
                            if (postData.videoURL && postData.videoURL.includes('firebase')) {
                                try {
                                    const videoRef = storage.refFromURL(postData.videoURL);
                                    deletePromises.push(videoRef.delete());
                                    console.log('ðŸ—‘ï¸ Deleting video from storage');
                                } catch (error) {
                                    console.warn('Could not delete video from storage:', error);
                                }
                            }
                            
                            // Wait for all storage deletions to complete (or fail)
                            Promise.allSettled(deletePromises)
                                .then((results) => {
                                    results.forEach((result, index) => {
                                        if (result.status === 'fulfilled') {
                                            console.log(`âœ… Media file ${index + 1} deleted from storage`);
                                        } else {
                                            console.warn(`âš ï¸ Could not delete media file ${index + 1}:`, result.reason);
                                        }
                                    });
                                })
                                .finally(() => {
                                    // Update local state regardless of storage deletion results
                                    updateLocalStateAfterDeletion(postId);
                                    hideLoading();
                                    alert('Post deleted successfully!');
                                });
                        })
                        .catch((error) => {
                            hideLoading();
                            console.error('Error deleting post from database:', error);
                            handleFirebaseError(error);
                        });
                })
                .catch((error) => {
                    hideLoading();
                    console.error('Error fetching post data:', error);
                    handleFirebaseError(error);
                });
        }
        
        // Update local state after post deletion
        function updateLocalStateAfterDeletion(postId) {
            // Remove from allPosts array
            const postIndex = allPosts.findIndex(p => p.id === postId);
            if (postIndex !== -1) {
                allPosts.splice(postIndex, 1);
                console.log('ðŸ—‘ï¸ Removed post from allPosts array');
            }
            
            // Remove from viewingQueue if present
            const queueIndex = viewingQueue.findIndex(p => p.id === postId);
            if (queueIndex !== -1) {
                viewingQueue.splice(queueIndex, 1);
                console.log('ðŸ—‘ï¸ Removed post from viewingQueue');
            }
            
            // Remove from recently disliked set
            recentlyDisliked.delete(postId);
            
            // If this was the current post being viewed, show next post
            if (currentPost && currentPost.id === postId) {
                console.log('ðŸ—‘ï¸ Deleted post was currently being viewed, showing next post');
                currentPost = null;
                goToNextPost();
            }
            
            // Remove from profile display if profile modal is open
            const profilePostElement = document.querySelector(`[data-post-id="${postId}"]`);
            if (profilePostElement) {
                profilePostElement.remove();
                console.log('ðŸ—‘ï¸ Removed post from profile display');
                
                // Check if this was the last post in the profile
                const remainingPosts = userPostsContainer.querySelectorAll('.profile-post-card');
                if (remainingPosts.length === 0) {
                    userPostsContainer.innerHTML = '<div class="no-posts">No posts yet</div>';
                    // Update user score to 0 when no posts remain
                    if (userScore) {
                        userScore.textContent = '0';
                    }
                } else {
                    // Recalculate and update user score based on remaining posts
                    let totalScore = 0;
                    remainingPosts.forEach(postCard => {
                        const postId = postCard.getAttribute('data-post-id');
                        const post = allPosts.find(p => p.id === postId);
                        if (post) {
                            const likes = post.likes || 0;
                            const dislikes = post.dislikes || 0;
                            totalScore += (likes - dislikes);
                        }
                    });
                    if (userScore) {
                        userScore.textContent = totalScore;
                    }
                }
            }
        }
        
        // DEBUG: Add debugging function to window for testing
        window.getFeedDebugInfo = function() {
            const debugInfo = {
                allPosts: allPosts.length,
                viewingQueue: viewingQueue.length,
                currentPost: currentPost ? `${currentPost.author} (${currentPost.id.substring(0, 8)})` : 'none',
                currentCycleIndex: currentCycleIndex,
                recentlyDisliked: recentlyDisliked.size,
                queueVersion: queueVersion,
                hideDislikedPosts: hideDislikedPosts,
                userDislikedPostsCount: userDislikedPosts.size,
                settingPersistent: 'âœ… (saved to Firebase)',
                topPosts: allPosts.slice(0, 5).map(p => ({
                    author: p.author,
                    score: (p.likes || 0) - (p.dislikes || 0),
                    id: p.id.substring(0, 8)
                })),
                queuePosts: viewingQueue.slice(0, 3).map(p => ({
                    author: p.author,
                    score: (p.likes || 0) - (p.dislikes || 0),
                    id: p.id.substring(0, 8)
                })),
                recentlyDislikedIds: Array.from(recentlyDisliked).map(id => id.substring(0, 8))
            };
            
            console.table(debugInfo);
            return debugInfo;
        };
        
        // Add manual refresh function for testing
        window.refreshFeed = function() {
            console.log('ðŸ”„ Manual feed refresh triggered');
            currentCycleIndex = 0;
            recentlyDisliked.clear();
            // Clear profile picture cache to get fresh data
            profilePictureCache.clear();
            
            // Refresh user's disliked posts from Firebase before refreshing feed
            if (currentUser) {
                refreshUserDislikedPosts().then(() => {
                    refreshViewingQueue();
                    showNextPost();
                    console.log('âœ… Feed refreshed manually with updated dislike filter');
                });
            } else {
                refreshViewingQueue();
                showNextPost();
                console.log('âœ… Feed refreshed manually');
            }
        };

        // NEW: Debug function to check disliked posts and verify filtering
        window.checkDislikedPosts = function() {
            console.log('ðŸ“‹ User currently disliked posts:', Array.from(userDislikedPosts));
            console.log('ðŸ”§ Hide disliked posts enabled:', hideDislikedPosts);
            
            if (currentUser) {
                // Check both liked and disliked posts to verify vote status
                Promise.all([
                    loadUserDislikedPosts(currentUser.uid),
                    usersRef.child(`${currentUser.uid}/likedPosts`).once('value')
                ]).then(([dislikedPosts, likedSnapshot]) => {
                    const likedData = likedSnapshot.val() || {};
                    const likedPosts = Object.keys(likedData).filter(postId => likedData[postId] === true);
                    
                    console.log('ðŸ“¦ Fresh data from Firebase:');
                    console.log('   Currently disliked posts:', Array.from(dislikedPosts));
                    console.log('   Currently liked posts:', likedPosts);
                    console.log('   Overlap (should be empty):', likedPosts.filter(postId => dislikedPosts.has(postId)));
                });
                
                loadHideDislikedSetting(currentUser.uid).then(setting => {
                    console.log('ðŸ’¾ Saved hide disliked setting from Firebase:', setting);
                });
            }
            
            return {
                userDislikedPosts: Array.from(userDislikedPosts),
                hideDislikedPosts: hideDislikedPosts,
                currentUser: currentUser ? currentUser.username : 'none'
            };
        };

        // NEW: Debug function to check user's vote status on current post
        window.checkUserVote = function(postId = null) {
            if (!currentUser) {
                console.log('âŒ No user logged in');
                return;
            }
            
            const targetPostId = postId || (currentPost ? currentPost.id : null);
            if (!targetPostId) {
                console.log('âŒ No post ID provided and no current post');
                return;
            }
            
            Promise.all([
                usersRef.child(`${currentUser.uid}/likedPosts/${targetPostId}`).once('value'),
                usersRef.child(`${currentUser.uid}/dislikedPosts/${targetPostId}`).once('value')
            ]).then(([likedSnapshot, dislikedSnapshot]) => {
                const hasLiked = likedSnapshot.exists();
                const hasDisliked = dislikedSnapshot.exists();
                
                console.log(`ðŸ—³ï¸ Vote status for post ${targetPostId.substring(0, 8)}:`);
                console.log(`   Liked: ${hasLiked}`);
                console.log(`   Disliked: ${hasDisliked}`);
                console.log(`   No vote: ${!hasLiked && !hasDisliked}`);
                
                return {
                    postId: targetPostId,
                    hasLiked,
                    hasDisliked,
                    noVote: !hasLiked && !hasDisliked
                };
            }).catch(error => {
                console.error('Error checking vote status:', error);
            });
        };

        // NEW: Debug function to simulate like/dislike for testing (updated for single-vote system)
        window.simulateSwipe = function(direction) {
            if (!currentPost) {
                console.log('âŒ No current post to swipe on');
                return;
            }
            
            console.log(`ðŸ§ª Simulating ${direction} swipe on: ${currentPost.author} (${currentPost.id.substring(0, 8)})`);
            
            // First check current vote status
            window.checkUserVote(currentPost.id);
            
            if (direction === 'left') {
                handlePostDislike(currentPost.id);
            } else if (direction === 'right') {
                handlePostLike(currentPost.id);
            }
            
            // Check vote status after a delay to see the change
            setTimeout(() => {
                window.checkUserVote(currentPost.id);
                goToNextPost();
            }, 1000);
        };

        // Clear profile cache when user updates their profile picture
        function clearProfileCache(userId) {
            if (userId) {
                profilePictureCache.delete(userId);
            } else {
                profilePictureCache.clear();
            }
        }
    </script>
</body>
</html>